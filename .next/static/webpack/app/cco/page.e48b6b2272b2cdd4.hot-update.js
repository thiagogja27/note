"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/cco/page",{

/***/ "(app-pages-browser)/./lib/realtime.ts":
/*!*************************!*\
  !*** ./lib/realtime.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNote: () => (/* binding */ addNote),\n/* harmony export */   deleteNote: () => (/* binding */ deleteNote),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getConfigErrorMessage: () => (/* binding */ getConfigErrorMessage),\n/* harmony export */   isFirebaseConfigured: () => (/* binding */ isFirebaseConfigured),\n/* harmony export */   listenToAllUserNotes: () => (/* binding */ listenToAllUserNotes),\n/* harmony export */   listenToInfoNotes: () => (/* binding */ listenToInfoNotes),\n/* harmony export */   listenToNotes: () => (/* binding */ listenToNotes),\n/* harmony export */   listenToRadarNotes: () => (/* binding */ listenToRadarNotes),\n/* harmony export */   listenToStorage: () => (/* binding */ listenToStorage),\n/* harmony export */   listenToStorageLogs: () => (/* binding */ listenToStorageLogs),\n/* harmony export */   saveOrUpdateUser: () => (/* binding */ saveOrUpdateUser),\n/* harmony export */   saveStorageSelection: () => (/* binding */ saveStorageSelection),\n/* harmony export */   toggleNoteCompleted: () => (/* binding */ toggleNoteCompleted),\n/* harmony export */   updateNote: () => (/* binding */ updateNote),\n/* harmony export */   validateUser: () => (/* binding */ validateUser)\n/* harmony export */ });\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/database */ \"(app-pages-browser)/./node_modules/firebase/database/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n/* harmony import */ var _types_note__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/note */ \"(app-pages-browser)/./types/note.ts\");\n/* __next_internal_client_entry_do_not_use__ isFirebaseConfigured,getConfigErrorMessage,listenToNotes,listenToAllUserNotes,listenToRadarNotes,listenToInfoNotes,addNote,updateNote,deleteNote,toggleNoteCompleted,listenToStorage,listenToStorageLogs,saveStorageSelection,saveOrUpdateUser,validateUser,getAllUsers auto */ \n\n\nconst COLLECTION_NAME = \"anotacoes\";\nconst STORAGE_COLLECTION = \"estocagem\";\nconst STORAGE_LOGS_COLLECTION = \"storage_logs\";\nconst STORAGE_DOC_ID = \"current\";\nconst USERS_COLLECTION = \"usuarios\";\nfunction isFirebaseConfigured() {\n    const hasApiKey = !!\"AIzaSyDjfV9hL9nu3cIQfVV8Yj7IdDnpZBtLY18\";\n    const hasProjectId = !!\"1:441739339291:web:597e21e95626a979cababe\";\n    const hasDatabaseUrl = !!\"https://anotacoes-ecc99-default-rtdb.firebaseio.com\";\n    return hasApiKey && hasProjectId && hasDatabaseUrl;\n}\nfunction getConfigErrorMessage() {\n    const missing = [];\n    if (false) {}\n    if (false) {}\n    if (false) {}\n    return \"Vari\\xe1veis de ambiente faltando: \".concat(missing.join(\", \"));\n}\nfunction createNotesListener(category, callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const notesRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, COLLECTION_NAME);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(notesRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            let notes = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    ...value,\n                    createdAt: new Date(value.createdAt || Date.now()),\n                    updatedAt: new Date(value.updatedAt || Date.now())\n                };\n            }).filter((note)=>!note.deleted);\n            if (category) {\n                notes = notes.filter((note)=>note.category === category);\n            }\n            notes.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            callback(notes);\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de notas:\", error);\n        return ()=>{};\n    }\n}\nfunction listenToNotes(userId, callback) {\n    return createNotesListener(null, (allNotes)=>{\n        const userNotes = allNotes.filter((note)=>note.userId === userId && ![\n                _types_note__WEBPACK_IMPORTED_MODULE_2__.RADAR_CATEGORY,\n                _types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY\n            ].includes(note.category));\n        callback(userNotes);\n    });\n}\n// NOVA FUNÇÃO PARA O SUPERVISOR\nfunction listenToAllUserNotes(callback) {\n    return createNotesListener(null, (allNotes)=>{\n        const userNotes = allNotes.filter((note)=>![\n                _types_note__WEBPACK_IMPORTED_MODULE_2__.RADAR_CATEGORY,\n                _types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY\n            ].includes(note.category));\n        callback(userNotes);\n    });\n}\nfunction listenToRadarNotes(callback) {\n    return createNotesListener(_types_note__WEBPACK_IMPORTED_MODULE_2__.RADAR_CATEGORY, callback);\n}\nfunction listenToInfoNotes(callback) {\n    return createNotesListener(_types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY, callback);\n}\nasync function addNote(noteData) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const notesRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, COLLECTION_NAME);\n    const newNoteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)(notesRef);\n    const now = new Date().toISOString();\n    const newNote = {\n        ...noteData,\n        createdAt: now,\n        updatedAt: now,\n        deleted: false\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(newNoteRef, newNote);\n    return {\n        id: newNoteRef.key,\n        ...newNote\n    };\n}\nasync function updateNote(id, noteData, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(COLLECTION_NAME, \"/\").concat(id));\n    const updatedAt = new Date().toISOString();\n    const updatedData = {\n        ...noteData,\n        updatedBy,\n        updatedByDepartment,\n        updatedAt\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, updatedData);\n}\nasync function deleteNote(id, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"anotacoes/\".concat(id));\n    const fieldsToUpdate = {\n        deleted: true,\n        updatedAt: new Date().toISOString(),\n        updatedBy,\n        updatedByDepartment\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, fieldsToUpdate);\n}\nasync function toggleNoteCompleted(id, completed, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(COLLECTION_NAME, \"/\").concat(id));\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, {\n        completed,\n        updatedBy,\n        updatedByDepartment,\n        updatedAt: new Date().toISOString()\n    });\n}\nfunction listenToStorage(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const storageRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(STORAGE_COLLECTION, \"/\").concat(STORAGE_DOC_ID));\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(storageRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback(null);\n                return;\n            }\n            callback({\n                id: STORAGE_DOC_ID,\n                ...data,\n                updatedAt: new Date(data.updatedAt)\n            });\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de estocagem:\", error);\n        return ()=>{};\n    }\n}\nfunction listenToStorageLogs(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const logsRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, STORAGE_LOGS_COLLECTION);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(logsRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            const logs = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    ...value,\n                    timestamp: new Date(value.timestamp)\n                };\n            });\n            logs.sort((a, b)=>b.timestamp.getTime() - a.timestamp.getTime());\n            callback(logs);\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de logs:\", error);\n        return ()=>{};\n    }\n}\nasync function saveStorageSelection(selection) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const timestampISO = new Date().toISOString();\n    const storageRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(STORAGE_COLLECTION, \"/\").concat(STORAGE_DOC_ID));\n    const dataToSave = {\n        tegRoad: selection.tegRoad,\n        tegRoadTombador: selection.tegRoadTombador,\n        tegRailwayMoega01: selection.tegRailwayMoega01,\n        tegRailwayMoega02: selection.tegRailwayMoega02,\n        teagRoad: selection.teagRoad,\n        teagRailway: selection.teagRailway,\n        updatedBy: selection.updatedBy,\n        updatedByDepartment: selection.updatedByDepartment,\n        updatedAt: timestampISO\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(storageRef, dataToSave);\n    const logRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)((0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, STORAGE_LOGS_COLLECTION));\n    const newLog = {\n        changedBy: selection.updatedBy,\n        department: selection.updatedByDepartment,\n        timestamp: timestampISO,\n        changes: {\n            tegRoad: selection.tegRoad,\n            tegRoadTombador: selection.tegRoadTombador,\n            tegRailwayMoega01: selection.tegRailwayMoega01,\n            tegRailwayMoega02: selection.tegRailwayMoega02,\n            teagRoad: selection.teagRoad,\n            teagRailway: selection.teagRailway\n        }\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(logRef, newLog);\n}\nasync function saveOrUpdateUser(user) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const userRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(USERS_COLLECTION, \"/\").concat(user.id));\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(userRef);\n        const userData = {\n            username: user.username,\n            password: user.password || \"\",\n            role: user.role,\n            department: user.department,\n            lastLogin: new Date().toISOString()\n        };\n        await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(userRef, userData);\n    } catch (error) {\n        console.error(\"[v0] Erro ao salvar usuário no banco:\", error);\n    }\n}\nasync function validateUser(username, password) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const usersRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, USERS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(usersRef);\n        const data = snapshot.val();\n        if (!data) return null;\n        const userEntry = Object.entries(data).find((param)=>{\n            let [, value] = param;\n            return value.username === username && value.password === password;\n        });\n        if (!userEntry) return null;\n        const [id, value] = userEntry;\n        const user = {\n            id,\n            ...value\n        };\n        const userRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(USERS_COLLECTION, \"/\").concat(id));\n        (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(userRef, {\n            lastLogin: new Date().toISOString()\n        });\n        return user;\n    } catch (error) {\n        console.error(\"Erro ao validar usuário:\", error);\n        return null;\n    }\n}\nasync function getAllUsers() {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const usersRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, USERS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(usersRef);\n        const data = snapshot.val();\n        if (!data) return [];\n        return Object.entries(data).map((param)=>{\n            let [id, value] = param;\n            return {\n                id,\n                ...value\n            };\n        });\n    } catch (error) {\n        console.error(\"Erro ao buscar usuários:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cyI6WyIvaG9tZS91c2VyL25vdGUvbGliL3JlYWx0aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCB7IHJlZiwgb25WYWx1ZSwgc2V0LCBwdXNoLCB1cGRhdGUsIGdldCB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiXG5pbXBvcnQgeyBnZXRGaXJlYmFzZURhdGFiYXNlIH0gZnJvbSBcIi4vZmlyZWJhc2VcIlxuaW1wb3J0IHR5cGUgeyBOb3RlLCBDYXRlZ29yeSB9IGZyb20gXCJAL3R5cGVzL25vdGVcIlxuaW1wb3J0IHsgSU5GT19DQVRFR09SWSwgUkFEQVJfQ0FURUdPUlkgfSBmcm9tIFwiQC90eXBlcy9ub3RlXCJcbmltcG9ydCB0eXBlIHsgVXNlciwgRGVwYXJ0bWVudCB9IGZyb20gXCJAL3R5cGVzL3VzZXJcIlxuaW1wb3J0IHR5cGUgeyBTdG9yYWdlU2VsZWN0aW9uLCBTdG9yYWdlTG9nIH0gZnJvbSBcIkAvdHlwZXMvc3RvcmFnZVwiXG5cbmNvbnN0IENPTExFQ1RJT05fTkFNRSA9IFwiYW5vdGFjb2VzXCJcbmNvbnN0IFNUT1JBR0VfQ09MTEVDVElPTiA9IFwiZXN0b2NhZ2VtXCJcbmNvbnN0IFNUT1JBR0VfTE9HU19DT0xMRUNUSU9OID0gXCJzdG9yYWdlX2xvZ3NcIlxuY29uc3QgU1RPUkFHRV9ET0NfSUQgPSBcImN1cnJlbnRcIlxuY29uc3QgVVNFUlNfQ09MTEVDVElPTiA9IFwidXN1YXJpb3NcIlxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlYmFzZUNvbmZpZ3VyZWQoKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhhc0FwaUtleSA9ICEhcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWVxuICBjb25zdCBoYXNQcm9qZWN0SWQgPSAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSURcbiAgY29uc3QgaGFzRGF0YWJhc2VVcmwgPSAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0RBVEFCQVNFX1VSTFxuICByZXR1cm4gaGFzQXBpS2V5ICYmIGhhc1Byb2plY3RJZCAmJiBoYXNEYXRhYmFzZVVybFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29uZmlnRXJyb3JNZXNzYWdlKCk6IHN0cmluZyB7XG4gIGNvbnN0IG1pc3Npbmc6IHN0cmluZ1tdID0gW11cbiAgaWYgKCFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZKSBtaXNzaW5nLnB1c2goXCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZXCIpXG4gIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCkgbWlzc2luZy5wdXNoKFwiTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRFwiKVxuICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0RBVEFCQVNFX1VSTCkgbWlzc2luZy5wdXNoKFwiTkVYVF9QVUJMSUNfRklSRUJBU0VfREFUQUJBU0VfVVJMXCIpXG4gIHJldHVybiBgVmFyacOhdmVpcyBkZSBhbWJpZW50ZSBmYWx0YW5kbzogJHttaXNzaW5nLmpvaW4oXCIsIFwiKX1gXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGVzTGlzdGVuZXIoY2F0ZWdvcnk6IENhdGVnb3J5IHwgc3RyaW5nIHwgbnVsbCwgY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgICBjb25zdCBub3Rlc1JlZiA9IHJlZihkYiwgQ09MTEVDVElPTl9OQU1FKVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb25WYWx1ZShub3Rlc1JlZiwgKHNuYXBzaG90KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKClcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhbXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBsZXQgbm90ZXM6IE5vdGVbXSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpXG4gICAgICAgIC5tYXAoKFtpZCwgdmFsdWVdOiBhbnkpID0+ICh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSh2YWx1ZS5jcmVhdGVkQXQgfHwgRGF0ZS5ub3coKSksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSh2YWx1ZS51cGRhdGVkQXQgfHwgRGF0ZS5ub3coKSksXG4gICAgICAgIH0pKVxuICAgICAgICAuZmlsdGVyKG5vdGUgPT4gIW5vdGUuZGVsZXRlZClcblxuICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgIG5vdGVzID0gbm90ZXMuZmlsdGVyKChub3RlKSA9PiBub3RlLmNhdGVnb3J5ID09PSBjYXRlZ29yeSlcbiAgICAgIH1cbiAgICAgIG5vdGVzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZEF0LmdldFRpbWUoKSAtIGEuY3JlYXRlZEF0LmdldFRpbWUoKSlcbiAgICAgIGNhbGxiYWNrKG5vdGVzKVxuICAgIH0pXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJybyBhbyBpbmljaWFyIGxpc3RlbmVyIGRlIG5vdGFzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9Ob3Rlcyh1c2VySWQ6IHN0cmluZywgY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vdGVzTGlzdGVuZXIobnVsbCwgKGFsbE5vdGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJOb3RlcyA9IGFsbE5vdGVzLmZpbHRlcihub3RlID0+IG5vdGUudXNlcklkID09PSB1c2VySWQgJiYgIVtSQURBUl9DQVRFR09SWSwgSU5GT19DQVRFR09SWV0uaW5jbHVkZXMobm90ZS5jYXRlZ29yeSkpO1xuICAgICAgICBjYWxsYmFjayh1c2VyTm90ZXMpO1xuICAgIH0pO1xufVxuXG4vLyBOT1ZBIEZVTsOHw4NPIFBBUkEgTyBTVVBFUlZJU09SXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9BbGxVc2VyTm90ZXMoY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gIHJldHVybiBjcmVhdGVOb3Rlc0xpc3RlbmVyKG51bGwsIChhbGxOb3RlcykgPT4ge1xuICAgIGNvbnN0IHVzZXJOb3RlcyA9IGFsbE5vdGVzLmZpbHRlcihub3RlID0+ICFbUkFEQVJfQ0FURUdPUlksIElORk9fQ0FURUdPUlldLmluY2x1ZGVzKG5vdGUuY2F0ZWdvcnkpKTtcbiAgICBjYWxsYmFjayh1c2VyTm90ZXMpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvUmFkYXJOb3RlcyhjYWxsYmFjazogKG5vdGVzOiBOb3RlW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgcmV0dXJuIGNyZWF0ZU5vdGVzTGlzdGVuZXIoUkFEQVJfQ0FURUdPUlksIGNhbGxiYWNrKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9JbmZvTm90ZXMoY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gIHJldHVybiBjcmVhdGVOb3Rlc0xpc3RlbmVyKElORk9fQ0FURUdPUlksIGNhbGxiYWNrKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkTm90ZShub3RlRGF0YTogT21pdDxOb3RlLCBcImlkXCIgfCBcImNyZWF0ZWRBdFwiIHwgXCJ1cGRhdGVkQXRcIj4pOiBQcm9taXNlPE5vdGU+IHtcbiAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgY29uc3Qgbm90ZXNSZWYgPSByZWYoZGIsIENPTExFQ1RJT05fTkFNRSlcbiAgY29uc3QgbmV3Tm90ZVJlZiA9IHB1c2gobm90ZXNSZWYpXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICBjb25zdCBuZXdOb3RlID0geyAuLi5ub3RlRGF0YSwgY3JlYXRlZEF0OiBub3csIHVwZGF0ZWRBdDogbm93LCBkZWxldGVkOiBmYWxzZSB9XG4gIGF3YWl0IHNldChuZXdOb3RlUmVmLCBuZXdOb3RlKVxuICByZXR1cm4geyBpZDogbmV3Tm90ZVJlZi5rZXkhLCAuLi5uZXdOb3RlIH0gYXMgdW5rbm93biBhcyBOb3RlXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVOb3RlKGlkOiBzdHJpbmcsIG5vdGVEYXRhOiBQYXJ0aWFsPE9taXQ8Tm90ZSwgXCJpZFwiPj4sIHVwZGF0ZWRCeTogc3RyaW5nLCB1cGRhdGVkQnlEZXBhcnRtZW50OiBEZXBhcnRtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gIGNvbnN0IG5vdGVSZWYgPSByZWYoZGIsIGAke0NPTExFQ1RJT05fTkFNRX0vJHtpZH1gKVxuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgY29uc3QgdXBkYXRlZERhdGEgPSB7IC4uLm5vdGVEYXRhLCB1cGRhdGVkQnksIHVwZGF0ZWRCeURlcGFydG1lbnQsIHVwZGF0ZWRBdCB9XG4gIGF3YWl0IHVwZGF0ZShub3RlUmVmLCB1cGRhdGVkRGF0YSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZU5vdGUoaWQ6IHN0cmluZywgdXBkYXRlZEJ5OiBzdHJpbmcsIHVwZGF0ZWRCeURlcGFydG1lbnQ6IERlcGFydG1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKCk7XG4gIGNvbnN0IG5vdGVSZWYgPSByZWYoZGIsIGBhbm90YWNvZXMvJHtpZH1gKTtcbiAgY29uc3QgZmllbGRzVG9VcGRhdGUgPSB7XG4gICAgZGVsZXRlZDogdHJ1ZSxcbiAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB1cGRhdGVkQnksXG4gICAgdXBkYXRlZEJ5RGVwYXJ0bWVudCxcbiAgfTtcbiAgYXdhaXQgdXBkYXRlKG5vdGVSZWYsIGZpZWxkc1RvVXBkYXRlKTsgXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0b2dnbGVOb3RlQ29tcGxldGVkKGlkOiBzdHJpbmcsIGNvbXBsZXRlZDogYm9vbGVhbiwgdXBkYXRlZEJ5OiBzdHJpbmcsIHVwZGF0ZWRCeURlcGFydG1lbnQ6IERlcGFydG1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgY29uc3Qgbm90ZVJlZiA9IHJlZihkYiwgYCR7Q09MTEVDVElPTl9OQU1FfS8ke2lkfWApXG4gIGF3YWl0IHVwZGF0ZShub3RlUmVmLCB7IGNvbXBsZXRlZCwgdXBkYXRlZEJ5LCB1cGRhdGVkQnlEZXBhcnRtZW50LCB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9TdG9yYWdlKGNhbGxiYWNrOiAoc3RvcmFnZTogU3RvcmFnZVNlbGVjdGlvbiB8IG51bGwpID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICAgIGNvbnN0IHN0b3JhZ2VSZWYgPSByZWYoZGIsIGAke1NUT1JBR0VfQ09MTEVDVElPTn0vJHtTVE9SQUdFX0RPQ19JRH1gKVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb25WYWx1ZShzdG9yYWdlUmVmLCAoc25hcHNob3QpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzbmFwc2hvdC52YWwoKVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FsbGJhY2soeyBpZDogU1RPUkFHRV9ET0NfSUQsIC4uLmRhdGEsIHVwZGF0ZWRBdDogbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpIH0pXG4gICAgfSlcbiAgICByZXR1cm4gdW5zdWJzY3JpYmVcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvIGFvIGluaWNpYXIgbGlzdGVuZXIgZGUgZXN0b2NhZ2VtOlwiLCBlcnJvcilcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9TdG9yYWdlTG9ncyhjYWxsYmFjazogKGxvZ3M6IFN0b3JhZ2VMb2dbXSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gICAgY29uc3QgbG9nc1JlZiA9IHJlZihkYiwgU1RPUkFHRV9MT0dTX0NPTExFQ1RJT04pXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBvblZhbHVlKGxvZ3NSZWYsIChzbmFwc2hvdCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHNuYXBzaG90LnZhbCgpXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgY2FsbGJhY2soW10pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgbG9nczogU3RvcmFnZUxvZ1tdID0gT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChbaWQsIHZhbHVlXTogYW55KSA9PiAoe1xuICAgICAgICBpZCxcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodmFsdWUudGltZXN0YW1wKSxcbiAgICAgIH0pKVxuICAgICAgbG9ncy5zb3J0KChhLCBiKSA9PiBiLnRpbWVzdGFtcC5nZXRUaW1lKCkgLSBhLnRpbWVzdGFtcC5nZXRUaW1lKCkpXG4gICAgICBjYWxsYmFjayhsb2dzKVxuICAgIH0pXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJybyBhbyBpbmljaWFyIGxpc3RlbmVyIGRlIGxvZ3M6XCIsIGVycm9yKVxuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlU3RvcmFnZVNlbGVjdGlvbihzZWxlY3Rpb246IE9taXQ8U3RvcmFnZVNlbGVjdGlvbiwgXCJpZFwiIHwgXCJ1cGRhdGVkQXRcIj4gJiB7IHVwZGF0ZWRCeTogc3RyaW5nOyB1cGRhdGVkQnlEZXBhcnRtZW50OiBEZXBhcnRtZW50IH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKCk7XG4gIGNvbnN0IHRpbWVzdGFtcElTTyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgY29uc3Qgc3RvcmFnZVJlZiA9IHJlZihkYiwgYCR7U1RPUkFHRV9DT0xMRUNUSU9OfS8ke1NUT1JBR0VfRE9DX0lEfWApO1xuXG4gIGNvbnN0IGRhdGFUb1NhdmUgPSB7XG4gICAgdGVnUm9hZDogc2VsZWN0aW9uLnRlZ1JvYWQsXG4gICAgdGVnUm9hZFRvbWJhZG9yOiBzZWxlY3Rpb24udGVnUm9hZFRvbWJhZG9yLFxuICAgIHRlZ1JhaWx3YXlNb2VnYTAxOiBzZWxlY3Rpb24udGVnUmFpbHdheU1vZWdhMDEsXG4gICAgdGVnUmFpbHdheU1vZWdhMDI6IHNlbGVjdGlvbi50ZWdSYWlsd2F5TW9lZ2EwMixcbiAgICB0ZWFnUm9hZDogc2VsZWN0aW9uLnRlYWdSb2FkLFxuICAgIHRlYWdSYWlsd2F5OiBzZWxlY3Rpb24udGVhZ1JhaWx3YXksXG4gICAgdXBkYXRlZEJ5OiBzZWxlY3Rpb24udXBkYXRlZEJ5LFxuICAgIHVwZGF0ZWRCeURlcGFydG1lbnQ6IHNlbGVjdGlvbi51cGRhdGVkQnlEZXBhcnRtZW50LFxuICAgIHVwZGF0ZWRBdDogdGltZXN0YW1wSVNPIGFzIGFueSxcbiAgfTtcblxuICBhd2FpdCBzZXQoc3RvcmFnZVJlZiwgZGF0YVRvU2F2ZSk7XG5cbiAgY29uc3QgbG9nUmVmID0gcHVzaChyZWYoZGIsIFNUT1JBR0VfTE9HU19DT0xMRUNUSU9OKSk7XG4gIGNvbnN0IG5ld0xvZzogT21pdDxTdG9yYWdlTG9nLCBcImlkXCI+ID0ge1xuICAgIGNoYW5nZWRCeTogc2VsZWN0aW9uLnVwZGF0ZWRCeSxcbiAgICBkZXBhcnRtZW50OiBzZWxlY3Rpb24udXBkYXRlZEJ5RGVwYXJ0bWVudCxcbiAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcElTTyBhcyBhbnksXG4gICAgY2hhbmdlczoge1xuICAgICAgdGVnUm9hZDogc2VsZWN0aW9uLnRlZ1JvYWQsXG4gICAgICB0ZWdSb2FkVG9tYmFkb3I6IHNlbGVjdGlvbi50ZWdSb2FkVG9tYmFkb3IsXG4gICAgICB0ZWdSYWlsd2F5TW9lZ2EwMTogc2VsZWN0aW9uLnRlZ1JhaWx3YXlNb2VnYTAxLFxuICAgICAgdGVnUmFpbHdheU1vZWdhMDI6IHNlbGVjdGlvbi50ZWdSYWlsd2F5TW9lZ2EwMixcbiAgICAgIHRlYWdSb2FkOiBzZWxlY3Rpb24udGVhZ1JvYWQsXG4gICAgICB0ZWFnUmFpbHdheTogc2VsZWN0aW9uLnRlYWdSYWlsd2F5LFxuICAgIH0sXG4gIH07XG4gIGF3YWl0IHNldChsb2dSZWYsIG5ld0xvZyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlT3JVcGRhdGVVc2VyKHVzZXI6IFVzZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKTtcbiAgICBjb25zdCB1c2VyUmVmID0gcmVmKGRiLCBgJHtVU0VSU19DT0xMRUNUSU9OfS8ke3VzZXIuaWR9YCk7XG4gICAgXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXQodXNlclJlZik7XG5cbiAgICBjb25zdCB1c2VyRGF0YSA9IHtcbiAgICAgIHVzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IHVzZXIucGFzc3dvcmQgfHwgXCJcIixcbiAgICAgIHJvbGU6IHVzZXIucm9sZSxcbiAgICAgIGRlcGFydG1lbnQ6IHVzZXIuZGVwYXJ0bWVudCxcbiAgICAgIGxhc3RMb2dpbjogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG5cbiAgICBhd2FpdCBzZXQodXNlclJlZiwgdXNlckRhdGEpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm8gYW8gc2FsdmFyIHVzdcOhcmlvIG5vIGJhbmNvOlwiLCBlcnJvcik7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVXNlcih1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpO1xuICAgIGNvbnN0IHVzZXJzUmVmID0gcmVmKGRiLCBVU0VSU19DT0xMRUNUSU9OKTtcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldCh1c2Vyc1JlZik7XG4gICAgY29uc3QgZGF0YSA9IHNuYXBzaG90LnZhbCgpO1xuICAgIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCB1c2VyRW50cnkgPSBPYmplY3QuZW50cmllcyhkYXRhKS5maW5kKChbLCB2YWx1ZV06IGFueSkgPT4gXG4gICAgICAgIHZhbHVlLnVzZXJuYW1lID09PSB1c2VybmFtZSAmJiB2YWx1ZS5wYXNzd29yZCA9PT0gcGFzc3dvcmRcbiAgICApO1xuXG4gICAgaWYgKCF1c2VyRW50cnkpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgW2lkLCB2YWx1ZV06IGFueSA9IHVzZXJFbnRyeTtcbiAgICBjb25zdCB1c2VyOiBVc2VyID0geyBpZCwgLi4udmFsdWUgfTtcblxuICAgIGNvbnN0IHVzZXJSZWYgPSByZWYoZGIsIGAke1VTRVJTX0NPTExFQ1RJT059LyR7aWR9YCk7XG4gICAgdXBkYXRlKHVzZXJSZWYsIHsgbGFzdExvZ2luOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSk7XG5cbiAgICByZXR1cm4gdXNlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyB2YWxpZGFyIHVzdcOhcmlvOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFVzZXJzKCk6IFByb21pc2U8VXNlcltdPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKCk7XG4gICAgICAgIGNvbnN0IHVzZXJzUmVmID0gcmVmKGRiLCBVU0VSU19DT0xMRUNUSU9OKTtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXQodXNlcnNSZWYpO1xuICAgICAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKCk7XG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5tYXAoKFtpZCwgdmFsdWVdOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIC4uLnZhbHVlXG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBidXNjYXIgdXN1w6FyaW9zOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsicmVmIiwib25WYWx1ZSIsInNldCIsInB1c2giLCJ1cGRhdGUiLCJnZXQiLCJnZXRGaXJlYmFzZURhdGFiYXNlIiwiSU5GT19DQVRFR09SWSIsIlJBREFSX0NBVEVHT1JZIiwiQ09MTEVDVElPTl9OQU1FIiwiU1RPUkFHRV9DT0xMRUNUSU9OIiwiU1RPUkFHRV9MT0dTX0NPTExFQ1RJT04iLCJTVE9SQUdFX0RPQ19JRCIsIlVTRVJTX0NPTExFQ1RJT04iLCJpc0ZpcmViYXNlQ29uZmlndXJlZCIsImhhc0FwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZIiwiaGFzUHJvamVjdElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCIsImhhc0RhdGFiYXNlVXJsIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfREFUQUJBU0VfVVJMIiwiZ2V0Q29uZmlnRXJyb3JNZXNzYWdlIiwibWlzc2luZyIsImpvaW4iLCJjcmVhdGVOb3Rlc0xpc3RlbmVyIiwiY2F0ZWdvcnkiLCJjYWxsYmFjayIsImRiIiwibm90ZXNSZWYiLCJ1bnN1YnNjcmliZSIsInNuYXBzaG90IiwiZGF0YSIsInZhbCIsIm5vdGVzIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsImlkIiwidmFsdWUiLCJjcmVhdGVkQXQiLCJEYXRlIiwibm93IiwidXBkYXRlZEF0IiwiZmlsdGVyIiwibm90ZSIsImRlbGV0ZWQiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiZXJyb3IiLCJjb25zb2xlIiwibGlzdGVuVG9Ob3RlcyIsInVzZXJJZCIsImFsbE5vdGVzIiwidXNlck5vdGVzIiwiaW5jbHVkZXMiLCJsaXN0ZW5Ub0FsbFVzZXJOb3RlcyIsImxpc3RlblRvUmFkYXJOb3RlcyIsImxpc3RlblRvSW5mb05vdGVzIiwiYWRkTm90ZSIsIm5vdGVEYXRhIiwibmV3Tm90ZVJlZiIsInRvSVNPU3RyaW5nIiwibmV3Tm90ZSIsImtleSIsInVwZGF0ZU5vdGUiLCJ1cGRhdGVkQnkiLCJ1cGRhdGVkQnlEZXBhcnRtZW50Iiwibm90ZVJlZiIsInVwZGF0ZWREYXRhIiwiZGVsZXRlTm90ZSIsImZpZWxkc1RvVXBkYXRlIiwidG9nZ2xlTm90ZUNvbXBsZXRlZCIsImNvbXBsZXRlZCIsImxpc3RlblRvU3RvcmFnZSIsInN0b3JhZ2VSZWYiLCJsaXN0ZW5Ub1N0b3JhZ2VMb2dzIiwibG9nc1JlZiIsImxvZ3MiLCJ0aW1lc3RhbXAiLCJzYXZlU3RvcmFnZVNlbGVjdGlvbiIsInNlbGVjdGlvbiIsInRpbWVzdGFtcElTTyIsImRhdGFUb1NhdmUiLCJ0ZWdSb2FkIiwidGVnUm9hZFRvbWJhZG9yIiwidGVnUmFpbHdheU1vZWdhMDEiLCJ0ZWdSYWlsd2F5TW9lZ2EwMiIsInRlYWdSb2FkIiwidGVhZ1JhaWx3YXkiLCJsb2dSZWYiLCJuZXdMb2ciLCJjaGFuZ2VkQnkiLCJkZXBhcnRtZW50IiwiY2hhbmdlcyIsInNhdmVPclVwZGF0ZVVzZXIiLCJ1c2VyIiwidXNlclJlZiIsInVzZXJEYXRhIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInJvbGUiLCJsYXN0TG9naW4iLCJ2YWxpZGF0ZVVzZXIiLCJ1c2Vyc1JlZiIsInVzZXJFbnRyeSIsImZpbmQiLCJnZXRBbGxVc2VycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/realtime.ts\n"));

/***/ })

});