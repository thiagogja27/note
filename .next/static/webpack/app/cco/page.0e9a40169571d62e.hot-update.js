"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/cco/page",{

/***/ "(app-pages-browser)/./lib/tasks.ts":
/*!**********************!*\
  !*** ./lib/tasks.ts ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addTask: () => (/* binding */ addTask),\n/* harmony export */   deleteTask: () => (/* binding */ deleteTask),\n/* harmony export */   getAllTasks: () => (/* binding */ getAllTasks),\n/* harmony export */   listenToTasks: () => (/* binding */ listenToTasks),\n/* harmony export */   listenToUserTasks: () => (/* binding */ listenToUserTasks),\n/* harmony export */   updateTask: () => (/* binding */ updateTask),\n/* harmony export */   updateTaskStatus: () => (/* binding */ updateTaskStatus)\n/* harmony export */ });\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/database */ \"(app-pages-browser)/./node_modules/firebase/database/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n/* __next_internal_client_entry_do_not_use__ listenToTasks,listenToUserTasks,getAllTasks,addTask,updateTask,deleteTask,updateTaskStatus auto */ \n\nconst TASKS_COLLECTION = \"tarefas\";\n// Helper function to remove properties with undefined values\nfunction cleanupObject(obj) {\n    const newObj = {};\n    for(const key in obj){\n        if (obj[key] !== undefined) {\n            newObj[key] = obj[key];\n        }\n    }\n    return newObj;\n}\nfunction listenToTasks(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const tasksRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, TASKS_COLLECTION);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(tasksRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            const tasks = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    title: value.title || \"\",\n                    description: value.description || \"\",\n                    priority: value.priority || \"media\",\n                    status: value.status || \"pendente\",\n                    shift: value.shift || \"todos\",\n                    assignedTo: value.assignedTo || [],\n                    assignedBy: value.assignedBy || \"\",\n                    assignedByDepartment: value.assignedByDepartment || \"supervisor\",\n                    dueDate: value.dueDate ? new Date(value.dueDate) : undefined,\n                    createdAt: new Date(value.createdAt || Date.now()),\n                    updatedAt: new Date(value.updatedAt || Date.now()),\n                    completedAt: value.completedAt ? new Date(value.completedAt) : undefined,\n                    completedBy: value.completedBy\n                };\n            });\n            tasks.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            callback(tasks);\n        }, (error)=>{\n            console.error(\"[v0] Erro na conexão de tarefas em tempo real:\", error);\n        });\n        return unsubscribe;\n    } catch (error) {\n        if (error.message && error.message.includes(\"Service database is not available\")) {\n            console.warn(\"[v0] Listener de tarefas não iniciado: Banco de dados indisponível.\");\n        } else {\n            console.error(\"[v0] Erro ao iniciar listener de tarefas:\", error);\n        }\n        return ()=>{};\n    }\n}\nfunction listenToUserTasks(username, callback) {\n    return listenToTasks((allTasks)=>{\n        const userTasks = allTasks.filter((task)=>task.assignedTo.includes(username));\n        callback(userTasks);\n    });\n}\nasync function getAllTasks() {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const tasksRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, TASKS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(tasksRef);\n        const data = snapshot.val();\n        if (!data) return [];\n        const tasks = Object.entries(data).map((param)=>{\n            let [id, value] = param;\n            return {\n                id,\n                title: value.title || \"\",\n                description: value.description || \"\",\n                priority: value.priority || \"media\",\n                status: value.status || \"pendente\",\n                shift: value.shift || \"todos\",\n                assignedTo: value.assignedTo || [],\n                assignedBy: value.assignedBy || \"\",\n                assignedByDepartment: value.assignedByDepartment || \"supervisor\",\n                dueDate: value.dueDate ? new Date(value.dueDate) : undefined,\n                createdAt: new Date(value.createdAt || Date.now()),\n                updatedAt: new Date(value.updatedAt || Date.now()),\n                completedAt: value.completedAt ? new Date(value.completedAt) : undefined,\n                completedBy: value.completedBy\n            };\n        });\n        return tasks.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n    } catch (error) {\n        if (error.message && error.message.includes(\"Service database is not available\")) {\n            console.warn(\"[v0] Aviso: Não foi possível buscar tarefas (Banco de dados indisponível).\");\n        } else {\n            console.error(\"Erro ao buscar tarefas:\", error);\n        }\n        return [];\n    }\n}\nasync function addTask(taskData) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const tasksRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, TASKS_COLLECTION);\n    const newTaskRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)(tasksRef);\n    const now = new Date().toISOString();\n    const newTaskPayload = {\n        ...taskData,\n        dueDate: taskData.dueDate ? new Date(taskData.dueDate).toISOString() : null,\n        completedAt: taskData.completedAt ? new Date(taskData.completedAt).toISOString() : null,\n        createdAt: now,\n        updatedAt: now\n    };\n    const finalPayload = cleanupObject(newTaskPayload);\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(newTaskRef, finalPayload);\n    return {\n        id: newTaskRef.key,\n        ...taskData,\n        createdAt: new Date(now),\n        updatedAt: new Date(now)\n    };\n}\nasync function updateTask(id, taskData) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const taskRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(TASKS_COLLECTION, \"/\").concat(id));\n    const updatedAt = new Date().toISOString();\n    const updatePayload = {\n        ...taskData,\n        updatedAt\n    };\n    if (taskData.hasOwnProperty('dueDate')) {\n        updatePayload.dueDate = taskData.dueDate ? new Date(taskData.dueDate).toISOString() : null;\n    }\n    if (taskData.hasOwnProperty('completedAt')) {\n        updatePayload.completedAt = taskData.completedAt ? new Date(taskData.completedAt).toISOString() : null;\n    }\n    const finalPayload = cleanupObject(updatePayload);\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(taskRef, finalPayload);\n}\nasync function deleteTask(id) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const taskRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(TASKS_COLLECTION, \"/\").concat(id));\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.remove)(taskRef);\n}\nasync function updateTaskStatus(id, status, completedBy) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const taskRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(TASKS_COLLECTION, \"/\").concat(id));\n    const now = new Date().toISOString();\n    const fieldsToUpdate = {\n        status,\n        updatedAt: now\n    };\n    if (status === \"concluida\" && completedBy) {\n        fieldsToUpdate.completedAt = now;\n        fieldsToUpdate.completedBy = completedBy;\n    }\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(taskRef, fieldsToUpdate);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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U0FBU1EsY0FBYyxDQUFDLGdCQUFnQjtRQUN4Q0QsY0FBYzFCLFdBQVcsR0FBR21CLFNBQVNuQixXQUFXLEdBQUcsSUFBSUosS0FBS3VCLFNBQVNuQixXQUFXLEVBQUVxQixXQUFXLEtBQUs7SUFDdEc7SUFFQSxNQUFNRSxlQUFldkQsY0FBYzBEO0lBRW5DLE1BQU0vRCx5REFBTUEsQ0FBQzhELFNBQVNGO0FBQzFCO0FBRU8sZUFBZUssV0FBVzNDLEVBQVU7SUFDekMsTUFBTVYsS0FBS1QsOERBQW1CQTtJQUM5QixNQUFNMkQsVUFBVWxFLHNEQUFHQSxDQUFDZ0IsSUFBSSxHQUF1QlUsT0FBcEJsQixrQkFBaUIsS0FBTSxPQUFIa0I7SUFDL0MsTUFBTXJCLHlEQUFNQSxDQUFDNkQ7QUFDZjtBQUVPLGVBQWVJLGlCQUFpQjVDLEVBQVUsRUFBRUssTUFBa0IsRUFBRVcsV0FBb0I7SUFDekYsTUFBTTFCLEtBQUtULDhEQUFtQkE7SUFDOUIsTUFBTTJELFVBQVVsRSxzREFBR0EsQ0FBQ2dCLElBQUksR0FBdUJVLE9BQXBCbEIsa0JBQWlCLEtBQU0sT0FBSGtCO0lBRS9DLE1BQU1hLE1BQU0sSUFBSUYsT0FBT3lCLFdBQVc7SUFDbEMsTUFBTVMsaUJBQXNCO1FBQUV4QztRQUFRUyxXQUFXRDtJQUFJO0lBRXJELElBQUlSLFdBQVcsZUFBZVcsYUFBYTtRQUN6QzZCLGVBQWU5QixXQUFXLEdBQUdGO1FBQzdCZ0MsZUFBZTdCLFdBQVcsR0FBR0E7SUFDL0I7SUFFQSxNQUFNdEMseURBQU1BLENBQUM4RCxTQUFTSztBQUN4QiIsInNvdXJjZXMiOlsiL2hvbWUvdXNlci9ub3RlL2xpYi90YXNrcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgeyByZWYsIG9uVmFsdWUsIHNldCwgcHVzaCwgdXBkYXRlLCByZW1vdmUsIGdldCB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiXG5pbXBvcnQgeyBnZXRGaXJlYmFzZURhdGFiYXNlIH0gZnJvbSBcIi4vZmlyZWJhc2VcIlxuaW1wb3J0IHR5cGUgeyBUYXNrLCBUYXNrU3RhdHVzIH0gZnJvbSBcIkAvdHlwZXMvdGFza1wiXG5pbXBvcnQgdHlwZSB7IERlcGFydG1lbnQgfSBmcm9tIFwiQC90eXBlcy91c2VyXCJcblxuY29uc3QgVEFTS1NfQ09MTEVDVElPTiA9IFwidGFyZWZhc1wiXG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byByZW1vdmUgcHJvcGVydGllcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcbmZ1bmN0aW9uIGNsZWFudXBPYmplY3Qob2JqOiBhbnkpIHtcbiAgY29uc3QgbmV3T2JqOiBhbnkgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdPYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5Ub1Rhc2tzKGNhbGxiYWNrOiAodGFza3M6IFRhc2tbXSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gICAgY29uc3QgdGFza3NSZWYgPSByZWYoZGIsIFRBU0tTX0NPTExFQ1RJT04pXG5cbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IG9uVmFsdWUoXG4gICAgICB0YXNrc1JlZixcbiAgICAgIChzbmFwc2hvdCkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKClcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgY2FsbGJhY2soW10pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXNrczogVGFza1tdID0gT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChbaWQsIHZhbHVlXTogYW55KSA9PiAoe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHRpdGxlOiB2YWx1ZS50aXRsZSB8fCBcIlwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgICAgIHByaW9yaXR5OiB2YWx1ZS5wcmlvcml0eSB8fCBcIm1lZGlhXCIsXG4gICAgICAgICAgc3RhdHVzOiB2YWx1ZS5zdGF0dXMgfHwgXCJwZW5kZW50ZVwiLFxuICAgICAgICAgIHNoaWZ0OiB2YWx1ZS5zaGlmdCB8fCBcInRvZG9zXCIsXG4gICAgICAgICAgYXNzaWduZWRUbzogdmFsdWUuYXNzaWduZWRUbyB8fCBbXSxcbiAgICAgICAgICBhc3NpZ25lZEJ5OiB2YWx1ZS5hc3NpZ25lZEJ5IHx8IFwiXCIsXG4gICAgICAgICAgYXNzaWduZWRCeURlcGFydG1lbnQ6IHZhbHVlLmFzc2lnbmVkQnlEZXBhcnRtZW50IHx8IFwic3VwZXJ2aXNvclwiLFxuICAgICAgICAgIGR1ZURhdGU6IHZhbHVlLmR1ZURhdGUgPyBuZXcgRGF0ZSh2YWx1ZS5kdWVEYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHZhbHVlLmNyZWF0ZWRBdCB8fCBEYXRlLm5vdygpKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKHZhbHVlLnVwZGF0ZWRBdCB8fCBEYXRlLm5vdygpKSxcbiAgICAgICAgICBjb21wbGV0ZWRBdDogdmFsdWUuY29tcGxldGVkQXQgPyBuZXcgRGF0ZSh2YWx1ZS5jb21wbGV0ZWRBdCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgY29tcGxldGVkQnk6IHZhbHVlLmNvbXBsZXRlZEJ5LFxuICAgICAgICB9KSlcblxuICAgICAgICB0YXNrcy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRBdC5nZXRUaW1lKCkgLSBhLmNyZWF0ZWRBdC5nZXRUaW1lKCkpXG4gICAgICAgIGNhbGxiYWNrKHRhc2tzKVxuICAgICAgfSxcbiAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvIG5hIGNvbmV4w6NvIGRlIHRhcmVmYXMgZW0gdGVtcG8gcmVhbDpcIiwgZXJyb3IpXG4gICAgICB9LFxuICAgIClcblxuICAgIHJldHVybiB1bnN1YnNjcmliZVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIlNlcnZpY2UgZGF0YWJhc2UgaXMgbm90IGF2YWlsYWJsZVwiKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW3YwXSBMaXN0ZW5lciBkZSB0YXJlZmFzIG7Do28gaW5pY2lhZG86IEJhbmNvIGRlIGRhZG9zIGluZGlzcG9uw612ZWwuXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm8gYW8gaW5pY2lhciBsaXN0ZW5lciBkZSB0YXJlZmFzOlwiLCBlcnJvcilcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHt9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvVXNlclRhc2tzKHVzZXJuYW1lOiBzdHJpbmcsIGNhbGxiYWNrOiAodGFza3M6IFRhc2tbXSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICByZXR1cm4gbGlzdGVuVG9UYXNrcygoYWxsVGFza3MpID0+IHtcbiAgICBjb25zdCB1c2VyVGFza3MgPSBhbGxUYXNrcy5maWx0ZXIodGFzayA9PiB0YXNrLmFzc2lnbmVkVG8uaW5jbHVkZXModXNlcm5hbWUpKTtcbiAgICBjYWxsYmFjayh1c2VyVGFza3MpO1xuICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFRhc2tzKCk6IFByb21pc2U8VGFza1tdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgICBjb25zdCB0YXNrc1JlZiA9IHJlZihkYiwgVEFTS1NfQ09MTEVDVElPTilcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldCh0YXNrc1JlZilcbiAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKClcblxuICAgIGlmICghZGF0YSkgcmV0dXJuIFtdXG5cbiAgICBjb25zdCB0YXNrczogVGFza1tdID0gT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChbaWQsIHZhbHVlXTogYW55KSA9PiAoe1xuICAgICAgaWQsXG4gICAgICB0aXRsZTogdmFsdWUudGl0bGUgfHwgXCJcIixcbiAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvbiB8fCBcIlwiLFxuICAgICAgcHJpb3JpdHk6IHZhbHVlLnByaW9yaXR5IHx8IFwibWVkaWFcIixcbiAgICAgIHN0YXR1czogdmFsdWUuc3RhdHVzIHx8IFwicGVuZGVudGVcIixcbiAgICAgIHNoaWZ0OiB2YWx1ZS5zaGlmdCB8fCBcInRvZG9zXCIsXG4gICAgICBhc3NpZ25lZFRvOiB2YWx1ZS5hc3NpZ25lZFRvIHx8IFtdLFxuICAgICAgYXNzaWduZWRCeTogdmFsdWUuYXNzaWduZWRCeSB8fCBcIlwiLFxuICAgICAgYXNzaWduZWRCeURlcGFydG1lbnQ6IHZhbHVlLmFzc2lnbmVkQnlEZXBhcnRtZW50IHx8IFwic3VwZXJ2aXNvclwiLFxuICAgICAgZHVlRGF0ZTogdmFsdWUuZHVlRGF0ZSA/IG5ldyBEYXRlKHZhbHVlLmR1ZURhdGUpIDogdW5kZWZpbmVkLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSh2YWx1ZS5jcmVhdGVkQXQgfHwgRGF0ZS5ub3coKSksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKHZhbHVlLnVwZGF0ZWRBdCB8fCBEYXRlLm5vdygpKSxcbiAgICAgIGNvbXBsZXRlZEF0OiB2YWx1ZS5jb21wbGV0ZWRBdCA/IG5ldyBEYXRlKHZhbHVlLmNvbXBsZXRlZEF0KSA6IHVuZGVmaW5lZCxcbiAgICAgIGNvbXBsZXRlZEJ5OiB2YWx1ZS5jb21wbGV0ZWRCeSxcbiAgICB9KSlcblxuICAgIHJldHVybiB0YXNrcy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRBdC5nZXRUaW1lKCkgLSBhLmNyZWF0ZWRBdC5nZXRUaW1lKCkpXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBpZiAoZXJyb3IubWVzc2FnZSAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiU2VydmljZSBkYXRhYmFzZSBpcyBub3QgYXZhaWxhYmxlXCIpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbdjBdIEF2aXNvOiBOw6NvIGZvaSBwb3Nzw612ZWwgYnVzY2FyIHRhcmVmYXMgKEJhbmNvIGRlIGRhZG9zIGluZGlzcG9uw612ZWwpLlwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBidXNjYXIgdGFyZWZhczpcIiwgZXJyb3IpXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRUYXNrKFxuICB0YXNrRGF0YTogT21pdDxUYXNrLCBcImlkXCIgfCBcImNyZWF0ZWRBdFwiIHwgXCJ1cGRhdGVkQXRcIj4gJiB7XG4gICAgYXNzaWduZWRCeTogc3RyaW5nXG4gICAgYXNzaWduZWRCeURlcGFydG1lbnQ6IERlcGFydG1lbnRcbiAgfSxcbik6IFByb21pc2U8VGFzaz4ge1xuICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICBjb25zdCB0YXNrc1JlZiA9IHJlZihkYiwgVEFTS1NfQ09MTEVDVElPTilcbiAgY29uc3QgbmV3VGFza1JlZiA9IHB1c2godGFza3NSZWYpXG5cbiAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIFxuICBjb25zdCBuZXdUYXNrUGF5bG9hZCA9IHtcbiAgICAuLi50YXNrRGF0YSxcbiAgICBkdWVEYXRlOiB0YXNrRGF0YS5kdWVEYXRlID8gbmV3IERhdGUodGFza0RhdGEuZHVlRGF0ZSkudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgY29tcGxldGVkQXQ6IHRhc2tEYXRhLmNvbXBsZXRlZEF0ID8gbmV3IERhdGUodGFza0RhdGEuY29tcGxldGVkQXQpLnRvSVNPU3RyaW5nKCkgOiBudWxsLFxuICAgIGNyZWF0ZWRBdDogbm93LFxuICAgIHVwZGF0ZWRBdDogbm93LFxuICB9O1xuXG4gIGNvbnN0IGZpbmFsUGF5bG9hZCA9IGNsZWFudXBPYmplY3QobmV3VGFza1BheWxvYWQpO1xuXG4gIGF3YWl0IHNldChuZXdUYXNrUmVmLCBmaW5hbFBheWxvYWQpO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IG5ld1Rhc2tSZWYua2V5ISxcbiAgICAuLi50YXNrRGF0YSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKG5vdyksXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZShub3cpLFxuICB9IGFzIFRhc2s7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVUYXNrKFxuICBpZDogc3RyaW5nLFxuICB0YXNrRGF0YTogUGFydGlhbDxPbWl0PFRhc2ssIFwiaWRcIiB8IFwiY3JlYXRlZEF0XCIgfCBcImFzc2lnbmVkQnlcIiB8IFwiYXNzaWduZWRCeURlcGFydG1lbnRcIj4gPixcbik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpO1xuICAgIGNvbnN0IHRhc2tSZWYgPSByZWYoZGIsIGAke1RBU0tTX0NPTExFQ1RJT059LyR7aWR9YCk7XG5cbiAgICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG5cbiAgICBjb25zdCB1cGRhdGVQYXlsb2FkOiBhbnkgPSB7IC4uLnRhc2tEYXRhLCB1cGRhdGVkQXQgfTtcblxuICAgIGlmICh0YXNrRGF0YS5oYXNPd25Qcm9wZXJ0eSgnZHVlRGF0ZScpKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQuZHVlRGF0ZSA9IHRhc2tEYXRhLmR1ZURhdGUgPyBuZXcgRGF0ZSh0YXNrRGF0YS5kdWVEYXRlKS50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG4gICAgaWYgKHRhc2tEYXRhLmhhc093blByb3BlcnR5KCdjb21wbGV0ZWRBdCcpKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQuY29tcGxldGVkQXQgPSB0YXNrRGF0YS5jb21wbGV0ZWRBdCA/IG5ldyBEYXRlKHRhc2tEYXRhLmNvbXBsZXRlZEF0KS50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmluYWxQYXlsb2FkID0gY2xlYW51cE9iamVjdCh1cGRhdGVQYXlsb2FkKTtcblxuICAgIGF3YWl0IHVwZGF0ZSh0YXNrUmVmLCBmaW5hbFBheWxvYWQpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVGFzayhpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gIGNvbnN0IHRhc2tSZWYgPSByZWYoZGIsIGAke1RBU0tTX0NPTExFQ1RJT059LyR7aWR9YClcbiAgYXdhaXQgcmVtb3ZlKHRhc2tSZWYpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVUYXNrU3RhdHVzKGlkOiBzdHJpbmcsIHN0YXR1czogVGFza1N0YXR1cywgY29tcGxldGVkQnk/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgY29uc3QgdGFza1JlZiA9IHJlZihkYiwgYCR7VEFTS1NfQ09MTEVDVElPTn0vJHtpZH1gKVxuXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICBjb25zdCBmaWVsZHNUb1VwZGF0ZTogYW55ID0geyBzdGF0dXMsIHVwZGF0ZWRBdDogbm93IH1cblxuICBpZiAoc3RhdHVzID09PSBcImNvbmNsdWlkYVwiICYmIGNvbXBsZXRlZEJ5KSB7XG4gICAgZmllbGRzVG9VcGRhdGUuY29tcGxldGVkQXQgPSBub3dcbiAgICBmaWVsZHNUb1VwZGF0ZS5jb21wbGV0ZWRCeSA9IGNvbXBsZXRlZEJ5XG4gIH1cblxuICBhd2FpdCB1cGRhdGUodGFza1JlZiwgZmllbGRzVG9VcGRhdGUpO1xufVxuIl0sIm5hbWVzIjpbInJlZiIsIm9uVmFsdWUiLCJzZXQiLCJwdXNoIiwidXBkYXRlIiwicmVtb3ZlIiwiZ2V0IiwiZ2V0RmlyZWJhc2VEYXRhYmFzZSIsIlRBU0tTX0NPTExFQ1RJT04iLCJjbGVhbnVwT2JqZWN0Iiwib2JqIiwibmV3T2JqIiwia2V5IiwidW5kZWZpbmVkIiwibGlzdGVuVG9UYXNrcyIsImNhbGxiYWNrIiwiZGIiLCJ0YXNrc1JlZiIsInVuc3Vic2NyaWJlIiwic25hcHNob3QiLCJkYXRhIiwidmFsIiwidGFza3MiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiaWQiLCJ2YWx1ZSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJwcmlvcml0eSIsInN0YXR1cyIsInNoaWZ0IiwiYXNzaWduZWRUbyIsImFzc2lnbmVkQnkiLCJhc3NpZ25lZEJ5RGVwYXJ0bWVudCIsImR1ZURhdGUiLCJEYXRlIiwiY3JlYXRlZEF0Iiwibm93IiwidXBkYXRlZEF0IiwiY29tcGxldGVkQXQiLCJjb21wbGV0ZWRCeSIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJlcnJvciIsImNvbnNvbGUiLCJtZXNzYWdlIiwiaW5jbHVkZXMiLCJ3YXJuIiwibGlzdGVuVG9Vc2VyVGFza3MiLCJ1c2VybmFtZSIsImFsbFRhc2tzIiwidXNlclRhc2tzIiwiZmlsdGVyIiwidGFzayIsImdldEFsbFRhc2tzIiwiYWRkVGFzayIsInRhc2tEYXRhIiwibmV3VGFza1JlZiIsInRvSVNPU3RyaW5nIiwibmV3VGFza1BheWxvYWQiLCJmaW5hbFBheWxvYWQiLCJ1cGRhdGVUYXNrIiwidGFza1JlZiIsInVwZGF0ZVBheWxvYWQiLCJoYXNPd25Qcm9wZXJ0eSIsImRlbGV0ZVRhc2siLCJ1cGRhdGVUYXNrU3RhdHVzIiwiZmllbGRzVG9VcGRhdGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/tasks.ts\n"));

/***/ })

});