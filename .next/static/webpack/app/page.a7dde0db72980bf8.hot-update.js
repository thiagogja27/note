"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/realtime.ts":
/*!*************************!*\
  !*** ./lib/realtime.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNote: () => (/* binding */ addNote),\n/* harmony export */   deleteNote: () => (/* binding */ deleteNote),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getConfigErrorMessage: () => (/* binding */ getConfigErrorMessage),\n/* harmony export */   isFirebaseConfigured: () => (/* binding */ isFirebaseConfigured),\n/* harmony export */   listenToInfoNotes: () => (/* binding */ listenToInfoNotes),\n/* harmony export */   listenToNotes: () => (/* binding */ listenToNotes),\n/* harmony export */   listenToRadarNotes: () => (/* binding */ listenToRadarNotes),\n/* harmony export */   listenToStorage: () => (/* binding */ listenToStorage),\n/* harmony export */   listenToStorageLogs: () => (/* binding */ listenToStorageLogs),\n/* harmony export */   saveOrUpdateUser: () => (/* binding */ saveOrUpdateUser),\n/* harmony export */   saveStorageSelection: () => (/* binding */ saveStorageSelection),\n/* harmony export */   toggleNoteCompleted: () => (/* binding */ toggleNoteCompleted),\n/* harmony export */   updateNote: () => (/* binding */ updateNote),\n/* harmony export */   validateUser: () => (/* binding */ validateUser)\n/* harmony export */ });\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/database */ \"(app-pages-browser)/./node_modules/firebase/database/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n/* harmony import */ var _types_note__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/note */ \"(app-pages-browser)/./types/note.ts\");\n/* __next_internal_client_entry_do_not_use__ isFirebaseConfigured,getConfigErrorMessage,listenToNotes,listenToRadarNotes,listenToInfoNotes,addNote,updateNote,deleteNote,toggleNoteCompleted,listenToStorage,listenToStorageLogs,saveStorageSelection,saveOrUpdateUser,validateUser,getAllUsers auto */ \n\n\nconst COLLECTION_NAME = \"anotacoes\";\nconst STORAGE_COLLECTION = \"estocagem\";\nconst STORAGE_LOGS_COLLECTION = \"storage_logs\";\nconst STORAGE_DOC_ID = \"current\";\nconst USERS_COLLECTION = \"usuarios\";\nfunction isFirebaseConfigured() {\n    const hasApiKey = !!\"AIzaSyDjfV9hL9nu3cIQfVV8Yj7IdDnpZBtLY18\";\n    const hasProjectId = !!\"1:441739339291:web:597e21e95626a979cababe\";\n    const hasDatabaseUrl = !!\"https://anotacoes-ecc99-default-rtdb.firebaseio.com\";\n    return hasApiKey && hasProjectId && hasDatabaseUrl;\n}\nfunction getConfigErrorMessage() {\n    const missing = [];\n    if (false) {}\n    if (false) {}\n    if (false) {}\n    return \"Vari\\xe1veis de ambiente faltando: \".concat(missing.join(\", \"));\n}\nfunction createNotesListener(category, callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const notesRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, COLLECTION_NAME);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(notesRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            let notes = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    ...value,\n                    createdAt: new Date(value.createdAt || Date.now()),\n                    updatedAt: new Date(value.updatedAt || Date.now())\n                };\n            }).filter((note)=>!note.deleted) // << CORREÇÃO IMPORTANTE: Garante que notas \"apagadas\" não apareçam\n            ;\n            if (category) {\n                notes = notes.filter((note)=>note.category === category);\n            }\n            notes.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            callback(notes);\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de notas:\", error);\n        return ()=>{};\n    }\n}\nfunction listenToNotes(userId, callback) {\n    return createNotesListener(null, (allNotes)=>{\n        const userNotes = allNotes.filter((note)=>note.userId === userId && ![\n                \"RADAR\",\n                _types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY\n            ].includes(note.category));\n        callback(userNotes);\n    });\n}\nfunction listenToRadarNotes(callback) {\n    return createNotesListener(\"RADAR\", callback);\n}\nfunction listenToInfoNotes(callback) {\n    return createNotesListener(_types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY, callback);\n}\nasync function addNote(noteData) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const notesRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, COLLECTION_NAME);\n    const newNoteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)(notesRef);\n    const now = new Date().toISOString();\n    const newNote = {\n        ...noteData,\n        createdAt: now,\n        updatedAt: now,\n        deleted: false\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(newNoteRef, newNote);\n    return {\n        id: newNoteRef.key,\n        ...newNote\n    };\n}\nasync function updateNote(id, noteData, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(COLLECTION_NAME, \"/\").concat(id));\n    const updatedAt = new Date().toISOString();\n    const updatedData = {\n        ...noteData,\n        updatedBy,\n        updatedByDepartment,\n        updatedAt\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, updatedData);\n}\n// << CORREÇÃO IMPORTANTE: Função alterada para fazer \"soft delete\"\n// Localização: lib/realtime.ts\nasync function deleteNote(id, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"anotacoes/\".concat(id)); // Prepara a referência para o item específico\n    // Define os campos a serem atualizados\n    const fieldsToUpdate = {\n        deleted: true,\n        updatedAt: new Date().toISOString(),\n        updatedBy,\n        updatedByDepartment\n    };\n    // Envia a atualização para o Firebase\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, fieldsToUpdate);\n}\nasync function toggleNoteCompleted(id, completed, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(COLLECTION_NAME, \"/\").concat(id));\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, {\n        completed,\n        updatedBy,\n        updatedByDepartment,\n        updatedAt: new Date().toISOString()\n    });\n}\n// O resto do ficheiro (listenToStorage, saveStorageSelection, etc.) permanece igual...\nfunction listenToStorage(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const storageRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(STORAGE_COLLECTION, \"/\").concat(STORAGE_DOC_ID));\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(storageRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback(null);\n                return;\n            }\n            callback({\n                id: STORAGE_DOC_ID,\n                ...data,\n                updatedAt: new Date(data.updatedAt)\n            });\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de estocagem:\", error);\n        return ()=>{};\n    }\n}\nfunction listenToStorageLogs(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const logsRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, STORAGE_LOGS_COLLECTION);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(logsRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            const logs = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    ...value,\n                    timestamp: new Date(value.timestamp)\n                };\n            });\n            logs.sort((a, b)=>b.timestamp.getTime() - a.timestamp.getTime());\n            callback(logs);\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de logs:\", error);\n        return ()=>{};\n    }\n}\nasync function saveStorageSelection(selection) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const timestamp = new Date();\n    const timestampISO = timestamp.toISOString();\n    const storageRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(STORAGE_COLLECTION, \"/\").concat(STORAGE_DOC_ID));\n    const updatedSelection = {\n        ...selection,\n        updatedAt: timestampISO\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(storageRef, updatedSelection);\n    const logRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)((0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, STORAGE_LOGS_COLLECTION));\n    const newLog = {\n        changedBy: selection.updatedBy,\n        department: selection.updatedByDepartment,\n        timestamp: timestampISO,\n        changes: {\n            tegRoad: selection.tegRoad,\n            tegRoadTombador: selection.tegRoadTombador,\n            tegRailwayMoega01: selection.tegRailwayMoega01,\n            tegRailwayMoega02: selection.tegRailwayMoega02,\n            teagRoad: selection.teagRoad,\n            teagRailway: selection.teagRailway\n        }\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(logRef, newLog);\n}\nasync function saveOrUpdateUser(user) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const userRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(USERS_COLLECTION, \"/\").concat(user.id));\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(userRef);\n        const existingUser = snapshot.val();\n        const userData = {\n            username: user.username,\n            password: user.password || \"\",\n            role: user.role,\n            department: user.department,\n            lastLogin: new Date().toISOString()\n        };\n        await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(userRef, userData);\n    } catch (error) {\n        console.error(\"[v0] Erro ao salvar usuário no banco:\", error);\n    }\n}\nasync function validateUser(username, password) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const usersRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, USERS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(usersRef);\n        const data = snapshot.val();\n        if (!data) return null;\n        const userEntry = Object.entries(data).find((param)=>{\n            let [, value] = param;\n            return value.username === username && value.password === password;\n        });\n        if (!userEntry) return null;\n        const [id, value] = userEntry;\n        const user = {\n            id,\n            ...value\n        };\n        const userRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(USERS_COLLECTION, \"/\").concat(id));\n        (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(userRef, {\n            lastLogin: new Date().toISOString()\n        });\n        return user;\n    } catch (error) {\n        console.error(\"Erro ao validar usuário:\", error);\n        return null;\n    }\n}\nasync function getAllUsers() {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const usersRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, USERS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(usersRef);\n        const data = snapshot.val();\n        if (!data) return [];\n        return Object.entries(data).map((param)=>{\n            let [id, value] = param;\n            return {\n                id,\n                ...value\n            };\n        });\n    } catch (error) {\n        console.error(\"Erro ao buscar usuários:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFBSSxHQUFHQyxLQUFLO1FBQUM7UUFFbEMsTUFBTTJELFVBQVVsRyxzREFBR0EsQ0FBQzRCLElBQUksR0FBdUJVLE9BQXBCMUIsa0JBQWlCLEtBQU0sT0FBSDBCO1FBQy9DbEMseURBQU1BLENBQUM4RixTQUFTO1lBQUVNLFdBQVcsSUFBSS9ELE9BQU9zQixXQUFXO1FBQUc7UUFFdEQsT0FBT2tDO0lBQ1QsRUFBRSxPQUFPOUMsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtRQUMxQyxPQUFPO0lBQ1Q7QUFDRjtBQUVPLGVBQWUwRDtJQUNsQixJQUFJO1FBQ0EsTUFBTWpGLEtBQUt0Qiw4REFBbUJBO1FBQzlCLE1BQU1vRyxXQUFXMUcsc0RBQUdBLENBQUM0QixJQUFJaEI7UUFDekIsTUFBTW1CLFdBQVcsTUFBTTFCLHNEQUFHQSxDQUFDcUc7UUFDM0IsTUFBTTFFLE9BQU9ELFNBQVNFLEdBQUc7UUFDekIsSUFBSSxDQUFDRCxNQUFNLE9BQU8sRUFBRTtRQUVwQixPQUFPRyxPQUFPQyxPQUFPLENBQUNKLE1BQU1LLEdBQUcsQ0FBQztnQkFBQyxDQUFDQyxJQUFJQyxNQUFXO21CQUFNO2dCQUNuREQ7Z0JBQ0EsR0FBR0MsS0FBSztZQUNaOztJQUNKLEVBQUUsT0FBT1ksT0FBTztRQUNaQyxRQUFRRCxLQUFLLENBQUMsNEJBQTRCQTtRQUMxQyxPQUFPLEVBQUU7SUFDYjtBQUNKIiwic291cmNlcyI6WyIvaG9tZS91c2VyL25vdGUvbGliL3JlYWx0aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCB7IHJlZiwgb25WYWx1ZSwgc2V0LCBwdXNoLCB1cGRhdGUsIGdldCB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiXG5pbXBvcnQgeyBnZXRGaXJlYmFzZURhdGFiYXNlIH0gZnJvbSBcIi4vZmlyZWJhc2VcIlxuaW1wb3J0IHR5cGUgeyBOb3RlLCBDYXRlZ29yeSB9IGZyb20gXCJAL3R5cGVzL25vdGVcIlxuaW1wb3J0IHsgSU5GT19DQVRFR09SWSB9IGZyb20gXCJAL3R5cGVzL25vdGVcIlxuaW1wb3J0IHR5cGUgeyBVc2VyLCBEZXBhcnRtZW50IH0gZnJvbSBcIkAvdHlwZXMvdXNlclwiXG5pbXBvcnQgdHlwZSB7IFN0b3JhZ2VTZWxlY3Rpb24sIFN0b3JhZ2VMb2cgfSBmcm9tIFwiQC90eXBlcy9zdG9yYWdlXCJcblxuY29uc3QgQ09MTEVDVElPTl9OQU1FID0gXCJhbm90YWNvZXNcIlxuY29uc3QgU1RPUkFHRV9DT0xMRUNUSU9OID0gXCJlc3RvY2FnZW1cIlxuY29uc3QgU1RPUkFHRV9MT0dTX0NPTExFQ1RJT04gPSBcInN0b3JhZ2VfbG9nc1wiXG5jb25zdCBTVE9SQUdFX0RPQ19JRCA9IFwiY3VycmVudFwiXG5jb25zdCBVU0VSU19DT0xMRUNUSU9OID0gXCJ1c3Vhcmlvc1wiXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmViYXNlQ29uZmlndXJlZCgpOiBib29sZWFuIHtcbiAgY29uc3QgaGFzQXBpS2V5ID0gISFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZXG4gIGNvbnN0IGhhc1Byb2plY3RJZCA9ICEhcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRFxuICBjb25zdCBoYXNEYXRhYmFzZVVybCA9ICEhcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfREFUQUJBU0VfVVJMXG4gIHJldHVybiBoYXNBcGlLZXkgJiYgaGFzUHJvamVjdElkICYmIGhhc0RhdGFiYXNlVXJsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWdFcnJvck1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgY29uc3QgbWlzc2luZzogc3RyaW5nW10gPSBbXVxuICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVkpIG1pc3NpbmcucHVzaChcIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVlcIilcbiAgaWYgKCFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9QUk9KRUNUX0lEKSBtaXNzaW5nLnB1c2goXCJORVhUX1BVQkxJQ19GSVJFQkFTRV9QUk9KRUNUX0lEXCIpXG4gIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfREFUQUJBU0VfVVJMKSBtaXNzaW5nLnB1c2goXCJORVhUX1BVQkxJQ19GSVJFQkFTRV9EQVRBQkFTRV9VUkxcIilcbiAgcmV0dXJuIGBWYXJpw6F2ZWlzIGRlIGFtYmllbnRlIGZhbHRhbmRvOiAke21pc3Npbmcuam9pbihcIiwgXCIpfWBcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm90ZXNMaXN0ZW5lcihjYXRlZ29yeTogQ2F0ZWdvcnkgfCBzdHJpbmcgfCBudWxsLCBjYWxsYmFjazogKG5vdGVzOiBOb3RlW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICAgIGNvbnN0IG5vdGVzUmVmID0gcmVmKGRiLCBDT0xMRUNUSU9OX05BTUUpXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBvblZhbHVlKG5vdGVzUmVmLCAoc25hcHNob3QpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzbmFwc2hvdC52YWwoKVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrKFtdKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGxldCBub3RlczogTm90ZVtdID0gT2JqZWN0LmVudHJpZXMoZGF0YSlcbiAgICAgICAgLm1hcCgoW2lkLCB2YWx1ZV06IGFueSkgPT4gKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKHZhbHVlLmNyZWF0ZWRBdCB8fCBEYXRlLm5vdygpKSxcbiAgICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKHZhbHVlLnVwZGF0ZWRBdCB8fCBEYXRlLm5vdygpKSxcbiAgICAgICAgfSkpXG4gICAgICAgIC5maWx0ZXIobm90ZSA9PiAhbm90ZS5kZWxldGVkKSAvLyA8PCBDT1JSRcOHw4NPIElNUE9SVEFOVEU6IEdhcmFudGUgcXVlIG5vdGFzIFwiYXBhZ2FkYXNcIiBuw6NvIGFwYXJlw6dhbVxuXG4gICAgICBpZiAoY2F0ZWdvcnkpIHtcbiAgICAgICAgbm90ZXMgPSBub3Rlcy5maWx0ZXIoKG5vdGUpID0+IG5vdGUuY2F0ZWdvcnkgPT09IGNhdGVnb3J5KVxuICAgICAgfVxuICAgICAgbm90ZXMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkQXQuZ2V0VGltZSgpIC0gYS5jcmVhdGVkQXQuZ2V0VGltZSgpKVxuICAgICAgY2FsbGJhY2sobm90ZXMpXG4gICAgfSlcbiAgICByZXR1cm4gdW5zdWJzY3JpYmVcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvIGFvIGluaWNpYXIgbGlzdGVuZXIgZGUgbm90YXM6XCIsIGVycm9yKVxuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5Ub05vdGVzKHVzZXJJZDogc3RyaW5nLCBjYWxsYmFjazogKG5vdGVzOiBOb3RlW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgICByZXR1cm4gY3JlYXRlTm90ZXNMaXN0ZW5lcihudWxsLCAoYWxsTm90ZXMpID0+IHtcbiAgICAgICAgY29uc3QgdXNlck5vdGVzID0gYWxsTm90ZXMuZmlsdGVyKG5vdGUgPT4gbm90ZS51c2VySWQgPT09IHVzZXJJZCAmJiAhW1wiUkFEQVJcIiwgSU5GT19DQVRFR09SWV0uaW5jbHVkZXMobm90ZS5jYXRlZ29yeSkpO1xuICAgICAgICBjYWxsYmFjayh1c2VyTm90ZXMpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9SYWRhck5vdGVzKGNhbGxiYWNrOiAobm90ZXM6IE5vdGVbXSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICByZXR1cm4gY3JlYXRlTm90ZXNMaXN0ZW5lcihcIlJBREFSXCIsIGNhbGxiYWNrKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9JbmZvTm90ZXMoY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gIHJldHVybiBjcmVhdGVOb3Rlc0xpc3RlbmVyKElORk9fQ0FURUdPUlksIGNhbGxiYWNrKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkTm90ZShub3RlRGF0YTogT21pdDxOb3RlLCBcImlkXCIgfCBcImNyZWF0ZWRBdFwiIHwgXCJ1cGRhdGVkQXRcIj4pOiBQcm9taXNlPE5vdGU+IHtcbiAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgY29uc3Qgbm90ZXNSZWYgPSByZWYoZGIsIENPTExFQ1RJT05fTkFNRSlcbiAgY29uc3QgbmV3Tm90ZVJlZiA9IHB1c2gobm90ZXNSZWYpXG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICBjb25zdCBuZXdOb3RlID0geyAuLi5ub3RlRGF0YSwgY3JlYXRlZEF0OiBub3csIHVwZGF0ZWRBdDogbm93LCBkZWxldGVkOiBmYWxzZSB9XG4gIGF3YWl0IHNldChuZXdOb3RlUmVmLCBuZXdOb3RlKVxuICByZXR1cm4geyBpZDogbmV3Tm90ZVJlZi5rZXkhLCAuLi5uZXdOb3RlIH0gYXMgdW5rbm93biBhcyBOb3RlXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVOb3RlKGlkOiBzdHJpbmcsIG5vdGVEYXRhOiBQYXJ0aWFsPE9taXQ8Tm90ZSwgXCJpZFwiPj4sIHVwZGF0ZWRCeTogc3RyaW5nLCB1cGRhdGVkQnlEZXBhcnRtZW50OiBEZXBhcnRtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gIGNvbnN0IG5vdGVSZWYgPSByZWYoZGIsIGAke0NPTExFQ1RJT05fTkFNRX0vJHtpZH1gKVxuICBjb25zdCB1cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgY29uc3QgdXBkYXRlZERhdGEgPSB7IC4uLm5vdGVEYXRhLCB1cGRhdGVkQnksIHVwZGF0ZWRCeURlcGFydG1lbnQsIHVwZGF0ZWRBdCB9XG4gIGF3YWl0IHVwZGF0ZShub3RlUmVmLCB1cGRhdGVkRGF0YSlcbn1cblxuLy8gPDwgQ09SUkXDh8ODTyBJTVBPUlRBTlRFOiBGdW7Dp8OjbyBhbHRlcmFkYSBwYXJhIGZhemVyIFwic29mdCBkZWxldGVcIlxuLy8gTG9jYWxpemHDp8OjbzogbGliL3JlYWx0aW1lLnRzXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVOb3RlKGlkOiBzdHJpbmcsIHVwZGF0ZWRCeTogc3RyaW5nLCB1cGRhdGVkQnlEZXBhcnRtZW50OiBEZXBhcnRtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpO1xuICBjb25zdCBub3RlUmVmID0gcmVmKGRiLCBgYW5vdGFjb2VzLyR7aWR9YCk7IC8vIFByZXBhcmEgYSByZWZlcsOqbmNpYSBwYXJhIG8gaXRlbSBlc3BlY8OtZmljb1xuICBcbiAgLy8gRGVmaW5lIG9zIGNhbXBvcyBhIHNlcmVtIGF0dWFsaXphZG9zXG4gIGNvbnN0IGZpZWxkc1RvVXBkYXRlID0ge1xuICAgIGRlbGV0ZWQ6IHRydWUsIC8vIEFwZW5hcyBtYXJjYSBvIGl0ZW0gY29tbyBhcGFnYWRvXG4gICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgdXBkYXRlZEJ5LFxuICAgIHVwZGF0ZWRCeURlcGFydG1lbnQsXG4gIH07XG5cbiAgLy8gRW52aWEgYSBhdHVhbGl6YcOnw6NvIHBhcmEgbyBGaXJlYmFzZVxuICBhd2FpdCB1cGRhdGUobm90ZVJlZiwgZmllbGRzVG9VcGRhdGUpOyBcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlTm90ZUNvbXBsZXRlZChpZDogc3RyaW5nLCBjb21wbGV0ZWQ6IGJvb2xlYW4sIHVwZGF0ZWRCeTogc3RyaW5nLCB1cGRhdGVkQnlEZXBhcnRtZW50OiBEZXBhcnRtZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gIGNvbnN0IG5vdGVSZWYgPSByZWYoZGIsIGAke0NPTExFQ1RJT05fTkFNRX0vJHtpZH1gKVxuICBhd2FpdCB1cGRhdGUobm90ZVJlZiwgeyBjb21wbGV0ZWQsIHVwZGF0ZWRCeSwgdXBkYXRlZEJ5RGVwYXJ0bWVudCwgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSlcbn1cblxuLy8gTyByZXN0byBkbyBmaWNoZWlybyAobGlzdGVuVG9TdG9yYWdlLCBzYXZlU3RvcmFnZVNlbGVjdGlvbiwgZXRjLikgcGVybWFuZWNlIGlndWFsLi4uXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9TdG9yYWdlKGNhbGxiYWNrOiAoc3RvcmFnZTogU3RvcmFnZVNlbGVjdGlvbiB8IG51bGwpID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICAgIGNvbnN0IHN0b3JhZ2VSZWYgPSByZWYoZGIsIGAke1NUT1JBR0VfQ09MTEVDVElPTn0vJHtTVE9SQUdFX0RPQ19JRH1gKVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb25WYWx1ZShzdG9yYWdlUmVmLCAoc25hcHNob3QpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzbmFwc2hvdC52YWwoKVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FsbGJhY2soeyBpZDogU1RPUkFHRV9ET0NfSUQsIC4uLmRhdGEsIHVwZGF0ZWRBdDogbmV3IERhdGUoZGF0YS51cGRhdGVkQXQpIH0pXG4gICAgfSlcbiAgICByZXR1cm4gdW5zdWJzY3JpYmVcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvIGFvIGluaWNpYXIgbGlzdGVuZXIgZGUgZXN0b2NhZ2VtOlwiLCBlcnJvcilcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9TdG9yYWdlTG9ncyhjYWxsYmFjazogKGxvZ3M6IFN0b3JhZ2VMb2dbXSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gICAgY29uc3QgbG9nc1JlZiA9IHJlZihkYiwgU1RPUkFHRV9MT0dTX0NPTExFQ1RJT04pXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBvblZhbHVlKGxvZ3NSZWYsIChzbmFwc2hvdCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IHNuYXBzaG90LnZhbCgpXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgY2FsbGJhY2soW10pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgbG9nczogU3RvcmFnZUxvZ1tdID0gT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChbaWQsIHZhbHVlXTogYW55KSA9PiAoe1xuICAgICAgICBpZCxcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUodmFsdWUudGltZXN0YW1wKSxcbiAgICAgIH0pKVxuICAgICAgbG9ncy5zb3J0KChhLCBiKSA9PiBiLnRpbWVzdGFtcC5nZXRUaW1lKCkgLSBhLnRpbWVzdGFtcC5nZXRUaW1lKCkpXG4gICAgICBjYWxsYmFjayhsb2dzKVxuICAgIH0pXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJybyBhbyBpbmljaWFyIGxpc3RlbmVyIGRlIGxvZ3M6XCIsIGVycm9yKVxuICAgIHJldHVybiAoKSA9PiB7fVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlU3RvcmFnZVNlbGVjdGlvbihzZWxlY3Rpb246IE9taXQ8U3RvcmFnZVNlbGVjdGlvbiwgXCJpZFwiIHwgXCJ1cGRhdGVkQXRcIj4gJiB7IHVwZGF0ZWRCeTogc3RyaW5nOyB1cGRhdGVkQnlEZXBhcnRtZW50OiBEZXBhcnRtZW50IH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKVxuICBjb25zdCB0aW1lc3RhbXBJU08gPSB0aW1lc3RhbXAudG9JU09TdHJpbmcoKVxuICBjb25zdCBzdG9yYWdlUmVmID0gcmVmKGRiLCBgJHtTVE9SQUdFX0NPTExFQ1RJT059LyR7U1RPUkFHRV9ET0NfSUR9YClcbiAgY29uc3QgdXBkYXRlZFNlbGVjdGlvbiA9IHsgLi4uc2VsZWN0aW9uLCB1cGRhdGVkQXQ6IHRpbWVzdGFtcElTTyB9XG4gIGF3YWl0IHNldChzdG9yYWdlUmVmLCB1cGRhdGVkU2VsZWN0aW9uKVxuXG4gIGNvbnN0IGxvZ1JlZiA9IHB1c2gocmVmKGRiLCBTVE9SQUdFX0xPR1NfQ09MTEVDVElPTikpXG4gIGNvbnN0IG5ld0xvZzogT21pdDxTdG9yYWdlTG9nLCBcImlkXCI+ID0ge1xuICAgIGNoYW5nZWRCeTogc2VsZWN0aW9uLnVwZGF0ZWRCeSxcbiAgICBkZXBhcnRtZW50OiBzZWxlY3Rpb24udXBkYXRlZEJ5RGVwYXJ0bWVudCxcbiAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcElTTyxcbiAgICBjaGFuZ2VzOiB7XG4gICAgICB0ZWdSb2FkOiBzZWxlY3Rpb24udGVnUm9hZCxcbiAgICAgIHRlZ1JvYWRUb21iYWRvcjogc2VsZWN0aW9uLnRlZ1JvYWRUb21iYWRvcixcbiAgICAgIHRlZ1JhaWx3YXlNb2VnYTAxOiBzZWxlY3Rpb24udGVnUmFpbHdheU1vZWdhMDEsXG4gICAgICB0ZWdSYWlsd2F5TW9lZ2EwMjogc2VsZWN0aW9uLnRlZ1JhaWx3YXlNb2VnYTAyLFxuICAgICAgdGVhZ1JvYWQ6IHNlbGVjdGlvbi50ZWFnUm9hZCxcbiAgICAgIHRlYWdSYWlsd2F5OiBzZWxlY3Rpb24udGVhZ1JhaWx3YXksXG4gICAgfSxcbiAgfVxuICBhd2FpdCBzZXQobG9nUmVmLCBuZXdMb2cpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlT3JVcGRhdGVVc2VyKHVzZXI6IFVzZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKTtcbiAgICBjb25zdCB1c2VyUmVmID0gcmVmKGRiLCBgJHtVU0VSU19DT0xMRUNUSU9OfS8ke3VzZXIuaWR9YCk7XG4gICAgXG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXQodXNlclJlZik7XG4gICAgY29uc3QgZXhpc3RpbmdVc2VyID0gc25hcHNob3QudmFsKCk7XG5cbiAgICBjb25zdCB1c2VyRGF0YSA9IHtcbiAgICAgIHVzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxuICAgICAgcGFzc3dvcmQ6IHVzZXIucGFzc3dvcmQgfHwgXCJcIixcbiAgICAgIHJvbGU6IHVzZXIucm9sZSxcbiAgICAgIGRlcGFydG1lbnQ6IHVzZXIuZGVwYXJ0bWVudCxcbiAgICAgIGxhc3RMb2dpbjogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH07XG5cbiAgICBhd2FpdCBzZXQodXNlclJlZiwgdXNlckRhdGEpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm8gYW8gc2FsdmFyIHVzdcOhcmlvIG5vIGJhbmNvOlwiLCBlcnJvcik7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVXNlcih1c2VybmFtZTogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpO1xuICAgIGNvbnN0IHVzZXJzUmVmID0gcmVmKGRiLCBVU0VSU19DT0xMRUNUSU9OKTtcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldCh1c2Vyc1JlZik7XG4gICAgY29uc3QgZGF0YSA9IHNuYXBzaG90LnZhbCgpO1xuICAgIGlmICghZGF0YSkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCB1c2VyRW50cnkgPSBPYmplY3QuZW50cmllcyhkYXRhKS5maW5kKChbLCB2YWx1ZV06IGFueSkgPT4gXG4gICAgICAgIHZhbHVlLnVzZXJuYW1lID09PSB1c2VybmFtZSAmJiB2YWx1ZS5wYXNzd29yZCA9PT0gcGFzc3dvcmRcbiAgICApO1xuXG4gICAgaWYgKCF1c2VyRW50cnkpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgW2lkLCB2YWx1ZV06IGFueSA9IHVzZXJFbnRyeTtcbiAgICBjb25zdCB1c2VyOiBVc2VyID0geyBpZCwgLi4udmFsdWUgfTtcblxuICAgIGNvbnN0IHVzZXJSZWYgPSByZWYoZGIsIGAke1VTRVJTX0NPTExFQ1RJT059LyR7aWR9YCk7XG4gICAgdXBkYXRlKHVzZXJSZWYsIHsgbGFzdExvZ2luOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSk7XG5cbiAgICByZXR1cm4gdXNlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyB2YWxpZGFyIHVzdcOhcmlvOlwiLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFVzZXJzKCk6IFByb21pc2U8VXNlcltdPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKCk7XG4gICAgICAgIGNvbnN0IHVzZXJzUmVmID0gcmVmKGRiLCBVU0VSU19DT0xMRUNUSU9OKTtcbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXQodXNlcnNSZWYpO1xuICAgICAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKCk7XG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhkYXRhKS5tYXAoKFtpZCwgdmFsdWVdOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIC4uLnZhbHVlXG4gICAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJybyBhbyBidXNjYXIgdXN1w6FyaW9zOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsicmVmIiwib25WYWx1ZSIsInNldCIsInB1c2giLCJ1cGRhdGUiLCJnZXQiLCJnZXRGaXJlYmFzZURhdGFiYXNlIiwiSU5GT19DQVRFR09SWSIsIkNPTExFQ1RJT05fTkFNRSIsIlNUT1JBR0VfQ09MTEVDVElPTiIsIlNUT1JBR0VfTE9HU19DT0xMRUNUSU9OIiwiU1RPUkFHRV9ET0NfSUQiLCJVU0VSU19DT0xMRUNUSU9OIiwiaXNGaXJlYmFzZUNvbmZpZ3VyZWQiLCJoYXNBcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSIsImhhc1Byb2plY3RJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQiLCJoYXNEYXRhYmFzZVVybCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0RBVEFCQVNFX1VSTCIsImdldENvbmZpZ0Vycm9yTWVzc2FnZSIsIm1pc3NpbmciLCJqb2luIiwiY3JlYXRlTm90ZXNMaXN0ZW5lciIsImNhdGVnb3J5IiwiY2FsbGJhY2siLCJkYiIsIm5vdGVzUmVmIiwidW5zdWJzY3JpYmUiLCJzbmFwc2hvdCIsImRhdGEiLCJ2YWwiLCJub3RlcyIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJpZCIsInZhbHVlIiwiY3JlYXRlZEF0IiwiRGF0ZSIsIm5vdyIsInVwZGF0ZWRBdCIsImZpbHRlciIsIm5vdGUiLCJkZWxldGVkIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsImVycm9yIiwiY29uc29sZSIsImxpc3RlblRvTm90ZXMiLCJ1c2VySWQiLCJhbGxOb3RlcyIsInVzZXJOb3RlcyIsImluY2x1ZGVzIiwibGlzdGVuVG9SYWRhck5vdGVzIiwibGlzdGVuVG9JbmZvTm90ZXMiLCJhZGROb3RlIiwibm90ZURhdGEiLCJuZXdOb3RlUmVmIiwidG9JU09TdHJpbmciLCJuZXdOb3RlIiwia2V5IiwidXBkYXRlTm90ZSIsInVwZGF0ZWRCeSIsInVwZGF0ZWRCeURlcGFydG1lbnQiLCJub3RlUmVmIiwidXBkYXRlZERhdGEiLCJkZWxldGVOb3RlIiwiZmllbGRzVG9VcGRhdGUiLCJ0b2dnbGVOb3RlQ29tcGxldGVkIiwiY29tcGxldGVkIiwibGlzdGVuVG9TdG9yYWdlIiwic3RvcmFnZVJlZiIsImxpc3RlblRvU3RvcmFnZUxvZ3MiLCJsb2dzUmVmIiwibG9ncyIsInRpbWVzdGFtcCIsInNhdmVTdG9yYWdlU2VsZWN0aW9uIiwic2VsZWN0aW9uIiwidGltZXN0YW1wSVNPIiwidXBkYXRlZFNlbGVjdGlvbiIsImxvZ1JlZiIsIm5ld0xvZyIsImNoYW5nZWRCeSIsImRlcGFydG1lbnQiLCJjaGFuZ2VzIiwidGVnUm9hZCIsInRlZ1JvYWRUb21iYWRvciIsInRlZ1JhaWx3YXlNb2VnYTAxIiwidGVnUmFpbHdheU1vZWdhMDIiLCJ0ZWFnUm9hZCIsInRlYWdSYWlsd2F5Iiwic2F2ZU9yVXBkYXRlVXNlciIsInVzZXIiLCJ1c2VyUmVmIiwiZXhpc3RpbmdVc2VyIiwidXNlckRhdGEiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwicm9sZSIsImxhc3RMb2dpbiIsInZhbGlkYXRlVXNlciIsInVzZXJzUmVmIiwidXNlckVudHJ5IiwiZmluZCIsImdldEFsbFVzZXJzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/realtime.ts\n"));

/***/ })

});