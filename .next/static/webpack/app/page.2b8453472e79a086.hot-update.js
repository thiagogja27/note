"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/realtime.ts":
/*!*************************!*\
  !*** ./lib/realtime.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNote: () => (/* binding */ addNote),\n/* harmony export */   deleteNote: () => (/* binding */ deleteNote),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getConfigErrorMessage: () => (/* binding */ getConfigErrorMessage),\n/* harmony export */   isFirebaseConfigured: () => (/* binding */ isFirebaseConfigured),\n/* harmony export */   listenToInfoNotes: () => (/* binding */ listenToInfoNotes),\n/* harmony export */   listenToNotes: () => (/* binding */ listenToNotes),\n/* harmony export */   listenToRadarNotes: () => (/* binding */ listenToRadarNotes),\n/* harmony export */   listenToStorage: () => (/* binding */ listenToStorage),\n/* harmony export */   listenToStorageLogs: () => (/* binding */ listenToStorageLogs),\n/* harmony export */   saveOrUpdateUser: () => (/* binding */ saveOrUpdateUser),\n/* harmony export */   saveStorageSelection: () => (/* binding */ saveStorageSelection),\n/* harmony export */   toggleNoteCompleted: () => (/* binding */ toggleNoteCompleted),\n/* harmony export */   updateNote: () => (/* binding */ updateNote),\n/* harmony export */   validateUser: () => (/* binding */ validateUser)\n/* harmony export */ });\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/database */ \"(app-pages-browser)/./node_modules/firebase/database/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n/* harmony import */ var _types_note__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/note */ \"(app-pages-browser)/./types/note.ts\");\n/* __next_internal_client_entry_do_not_use__ isFirebaseConfigured,getConfigErrorMessage,listenToNotes,listenToRadarNotes,listenToInfoNotes,addNote,updateNote,deleteNote,toggleNoteCompleted,listenToStorage,listenToStorageLogs,saveStorageSelection,saveOrUpdateUser,validateUser,getAllUsers auto */ \n\n\nconst COLLECTION_NAME = \"anotacoes\";\nconst STORAGE_COLLECTION = \"estocagem\";\nconst STORAGE_LOGS_COLLECTION = \"storage_logs\";\nconst STORAGE_DOC_ID = \"current\";\nconst USERS_COLLECTION = \"usuarios\";\nfunction isFirebaseConfigured() {\n    const hasApiKey = !!\"AIzaSyDjfV9hL9nu3cIQfVV8Yj7IdDnpZBtLY18\";\n    const hasProjectId = !!\"1:441739339291:web:597e21e95626a979cababe\";\n    const hasDatabaseUrl = !!\"https://anotacoes-ecc99-default-rtdb.firebaseio.com\";\n    return hasApiKey && hasProjectId && hasDatabaseUrl;\n}\nfunction getConfigErrorMessage() {\n    const missing = [];\n    if (false) {}\n    if (false) {}\n    if (false) {}\n    return \"Vari\\xe1veis de ambiente faltando: \".concat(missing.join(\", \"));\n}\nfunction createNotesListener(category, callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const notesRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, COLLECTION_NAME);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(notesRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            let notes = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    ...value,\n                    createdAt: new Date(value.createdAt || Date.now()),\n                    updatedAt: new Date(value.updatedAt || Date.now())\n                };\n            }).filter((note)=>!note.deleted) // << CORREÇÃO IMPORTANTE: Garante que notas \"apagadas\" não apareçam\n            ;\n            if (category) {\n                notes = notes.filter((note)=>note.category === category);\n            }\n            notes.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            callback(notes);\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de notas:\", error);\n        return ()=>{};\n    }\n}\nfunction listenToNotes(userId, callback) {\n    return createNotesListener(null, (allNotes)=>{\n        const userNotes = allNotes.filter((note)=>note.userId === userId && ![\n                \"RADAR\",\n                _types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY\n            ].includes(note.category));\n        callback(userNotes);\n    });\n}\nfunction listenToRadarNotes(callback) {\n    return createNotesListener(\"RADAR\", callback);\n}\nfunction listenToInfoNotes(callback) {\n    return createNotesListener(_types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY, callback);\n}\nasync function addNote(noteData) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const notesRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, COLLECTION_NAME);\n    const newNoteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)(notesRef);\n    const now = new Date().toISOString();\n    const newNote = {\n        ...noteData,\n        createdAt: now,\n        updatedAt: now,\n        deleted: false\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(newNoteRef, newNote);\n    return {\n        id: newNoteRef.key,\n        ...newNote\n    };\n}\nasync function updateNote(id, noteData, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(COLLECTION_NAME, \"/\").concat(id));\n    const updatedAt = new Date().toISOString();\n    const updatedData = {\n        ...noteData,\n        updatedBy,\n        updatedByDepartment,\n        updatedAt\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, updatedData);\n}\n// << CORREÇÃO IMPORTANTE: Função alterada para fazer \"soft delete\"\n// Localização: lib/realtime.ts\nasync function deleteNote(id, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"anotacoes/\".concat(id)); // Prepara a referência para o item específico\n    // Define os campos a serem atualizados\n    const fieldsToUpdate = {\n        deleted: true,\n        updatedAt: new Date().toISOString(),\n        updatedBy,\n        updatedByDepartment\n    };\n    // Envia a atualização para o Firebase\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, fieldsToUpdate);\n}\nasync function toggleNoteCompleted(id, completed, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(COLLECTION_NAME, \"/\").concat(id));\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, {\n        completed,\n        updatedBy,\n        updatedByDepartment,\n        updatedAt: new Date().toISOString()\n    });\n}\n// O resto do ficheiro (listenToStorage, saveStorageSelection, etc.) permanece igual...\nfunction listenToStorage(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const storageRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(STORAGE_COLLECTION, \"/\").concat(STORAGE_DOC_ID));\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(storageRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback(null);\n                return;\n            }\n            callback({\n                id: STORAGE_DOC_ID,\n                ...data,\n                updatedAt: new Date(data.updatedAt)\n            });\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de estocagem:\", error);\n        return ()=>{};\n    }\n}\nfunction listenToStorageLogs(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const logsRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, STORAGE_LOGS_COLLECTION);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(logsRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            const logs = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    ...value,\n                    timestamp: new Date(value.timestamp)\n                };\n            });\n            logs.sort((a, b)=>b.timestamp.getTime() - a.timestamp.getTime());\n            callback(logs);\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de logs:\", error);\n        return ()=>{};\n    }\n}\nasync function saveStorageSelection(selection) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const timestampISO = new Date().toISOString(); // <<-- Gerar a string ISO\n    const storageRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(STORAGE_COLLECTION, \"/\").concat(STORAGE_DOC_ID));\n    const dataToSave = {\n        tegRoad: selection.tegRoad,\n        tegRoadTombador: selection.tegRoadTombador,\n        tegRailwayMoega01: selection.tegRailwayMoega01,\n        tegRailwayMoega02: selection.tegRailwayMoega02,\n        teagRoad: selection.teagRoad,\n        teagRailway: selection.teagRailway,\n        updatedBy: selection.updatedBy,\n        updatedByDepartment: selection.updatedByDepartment,\n        updatedAt: timestampISO\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(storageRef, dataToSave);\n    const logRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)((0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, STORAGE_LOGS_COLLECTION));\n    const newLog = {\n        changedBy: selection.updatedBy,\n        department: selection.updatedByDepartment,\n        timestamp: timestampISO,\n        changes: {\n            tegRoad: selection.tegRoad,\n            tegRoadTombador: selection.tegRoadTombador,\n            tegRailwayMoega01: selection.tegRailwayMoega01,\n            tegRailwayMoega02: selection.tegRailwayMoega02,\n            teagRoad: selection.teagRoad,\n            teagRailway: selection.teagRailway\n        }\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(logRef, newLog);\n}\nasync function saveOrUpdateUser(user) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const userRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(USERS_COLLECTION, \"/\").concat(user.id));\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(userRef);\n        const existingUser = snapshot.val();\n        const userData = {\n            username: user.username,\n            password: user.password || \"\",\n            role: user.role,\n            department: user.department,\n            lastLogin: new Date().toISOString()\n        };\n        await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(userRef, userData);\n    } catch (error) {\n        console.error(\"[v0] Erro ao salvar usuário no banco:\", error);\n    }\n}\nasync function validateUser(username, password) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const usersRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, USERS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(usersRef);\n        const data = snapshot.val();\n        if (!data) return null;\n        const userEntry = Object.entries(data).find((param)=>{\n            let [, value] = param;\n            return value.username === username && value.password === password;\n        });\n        if (!userEntry) return null;\n        const [id, value] = userEntry;\n        const user = {\n            id,\n            ...value\n        };\n        const userRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(USERS_COLLECTION, \"/\").concat(id));\n        (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(userRef, {\n            lastLogin: new Date().toISOString()\n        });\n        return user;\n    } catch (error) {\n        console.error(\"Erro ao validar usuário:\", error);\n        return null;\n    }\n}\nasync function getAllUsers() {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const usersRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, USERS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(usersRef);\n        const data = snapshot.val();\n        if (!data) return [];\n        return Object.entries(data).map((param)=>{\n            let [id, value] = param;\n            return {\n                id,\n                ...value\n            };\n        });\n    } catch (error) {\n        console.error(\"Erro ao buscar usuários:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUNKLE1BQU00RSxJQUFJLENBQUM7Z0JBQUMsR0FBR3JFLE1BQVc7bUJBQ3ZEQSxNQUFNOEQsUUFBUSxLQUFLQSxZQUFZOUQsTUFBTStELFFBQVEsS0FBS0E7O1FBR3RELElBQUksQ0FBQ0ssV0FBVyxPQUFPO1FBRXZCLE1BQU0sQ0FBQ3JFLElBQUlDLE1BQU0sR0FBUW9FO1FBQ3pCLE1BQU1WLE9BQWE7WUFBRTNEO1lBQUksR0FBR0MsS0FBSztRQUFDO1FBRWxDLE1BQU0yRCxVQUFVbEcsc0RBQUdBLENBQUM0QixJQUFJLEdBQXVCVSxPQUFwQjFCLGtCQUFpQixLQUFNLE9BQUgwQjtRQUMvQ2xDLHlEQUFNQSxDQUFDOEYsU0FBUztZQUFFTSxXQUFXLElBQUkvRCxPQUFPc0IsV0FBVztRQUFHO1FBRXRELE9BQU9rQztJQUNULEVBQUUsT0FBTzlDLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsT0FBTztJQUNUO0FBQ0Y7QUFFTyxlQUFlMEQ7SUFDbEIsSUFBSTtRQUNBLE1BQU1qRixLQUFLdEIsOERBQW1CQTtRQUM5QixNQUFNb0csV0FBVzFHLHNEQUFHQSxDQUFDNEIsSUFBSWhCO1FBQ3pCLE1BQU1tQixXQUFXLE1BQU0xQixzREFBR0EsQ0FBQ3FHO1FBQzNCLE1BQU0xRSxPQUFPRCxTQUFTRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ0QsTUFBTSxPQUFPLEVBQUU7UUFFcEIsT0FBT0csT0FBT0MsT0FBTyxDQUFDSixNQUFNSyxHQUFHLENBQUM7Z0JBQUMsQ0FBQ0MsSUFBSUMsTUFBVzttQkFBTTtnQkFDbkREO2dCQUNBLEdBQUdDLEtBQUs7WUFDWjs7SUFDSixFQUFFLE9BQU9ZLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsT0FBTyxFQUFFO0lBQ2I7QUFDSiIsInNvdXJjZXMiOlsiL2hvbWUvdXNlci9ub3RlL2xpYi9yZWFsdGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgeyByZWYsIG9uVmFsdWUsIHNldCwgcHVzaCwgdXBkYXRlLCBnZXQgfSBmcm9tIFwiZmlyZWJhc2UvZGF0YWJhc2VcIlxuaW1wb3J0IHsgZ2V0RmlyZWJhc2VEYXRhYmFzZSB9IGZyb20gXCIuL2ZpcmViYXNlXCJcbmltcG9ydCB0eXBlIHsgTm90ZSwgQ2F0ZWdvcnkgfSBmcm9tIFwiQC90eXBlcy9ub3RlXCJcbmltcG9ydCB7IElORk9fQ0FURUdPUlkgfSBmcm9tIFwiQC90eXBlcy9ub3RlXCJcbmltcG9ydCB0eXBlIHsgVXNlciwgRGVwYXJ0bWVudCB9IGZyb20gXCJAL3R5cGVzL3VzZXJcIlxuaW1wb3J0IHR5cGUgeyBTdG9yYWdlU2VsZWN0aW9uLCBTdG9yYWdlTG9nIH0gZnJvbSBcIkAvdHlwZXMvc3RvcmFnZVwiXG5cbmNvbnN0IENPTExFQ1RJT05fTkFNRSA9IFwiYW5vdGFjb2VzXCJcbmNvbnN0IFNUT1JBR0VfQ09MTEVDVElPTiA9IFwiZXN0b2NhZ2VtXCJcbmNvbnN0IFNUT1JBR0VfTE9HU19DT0xMRUNUSU9OID0gXCJzdG9yYWdlX2xvZ3NcIlxuY29uc3QgU1RPUkFHRV9ET0NfSUQgPSBcImN1cnJlbnRcIlxuY29uc3QgVVNFUlNfQ09MTEVDVElPTiA9IFwidXN1YXJpb3NcIlxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlYmFzZUNvbmZpZ3VyZWQoKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhhc0FwaUtleSA9ICEhcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWVxuICBjb25zdCBoYXNQcm9qZWN0SWQgPSAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSURcbiAgY29uc3QgaGFzRGF0YWJhc2VVcmwgPSAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0RBVEFCQVNFX1VSTFxuICByZXR1cm4gaGFzQXBpS2V5ICYmIGhhc1Byb2plY3RJZCAmJiBoYXNEYXRhYmFzZVVybFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29uZmlnRXJyb3JNZXNzYWdlKCk6IHN0cmluZyB7XG4gIGNvbnN0IG1pc3Npbmc6IHN0cmluZ1tdID0gW11cbiAgaWYgKCFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZKSBtaXNzaW5nLnB1c2goXCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZXCIpXG4gIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCkgbWlzc2luZy5wdXNoKFwiTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRFwiKVxuICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0RBVEFCQVNFX1VSTCkgbWlzc2luZy5wdXNoKFwiTkVYVF9QVUJMSUNfRklSRUJBU0VfREFUQUJBU0VfVVJMXCIpXG4gIHJldHVybiBgVmFyacOhdmVpcyBkZSBhbWJpZW50ZSBmYWx0YW5kbzogJHttaXNzaW5nLmpvaW4oXCIsIFwiKX1gXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGVzTGlzdGVuZXIoY2F0ZWdvcnk6IENhdGVnb3J5IHwgc3RyaW5nIHwgbnVsbCwgY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgICBjb25zdCBub3Rlc1JlZiA9IHJlZihkYiwgQ09MTEVDVElPTl9OQU1FKVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb25WYWx1ZShub3Rlc1JlZiwgKHNuYXBzaG90KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKClcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhbXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBsZXQgbm90ZXM6IE5vdGVbXSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpXG4gICAgICAgIC5tYXAoKFtpZCwgdmFsdWVdOiBhbnkpID0+ICh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSh2YWx1ZS5jcmVhdGVkQXQgfHwgRGF0ZS5ub3coKSksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSh2YWx1ZS51cGRhdGVkQXQgfHwgRGF0ZS5ub3coKSksXG4gICAgICAgIH0pKVxuICAgICAgICAuZmlsdGVyKG5vdGUgPT4gIW5vdGUuZGVsZXRlZCkgLy8gPDwgQ09SUkXDh8ODTyBJTVBPUlRBTlRFOiBHYXJhbnRlIHF1ZSBub3RhcyBcImFwYWdhZGFzXCIgbsOjbyBhcGFyZcOnYW1cblxuICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgIG5vdGVzID0gbm90ZXMuZmlsdGVyKChub3RlKSA9PiBub3RlLmNhdGVnb3J5ID09PSBjYXRlZ29yeSlcbiAgICAgIH1cbiAgICAgIG5vdGVzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZEF0LmdldFRpbWUoKSAtIGEuY3JlYXRlZEF0LmdldFRpbWUoKSlcbiAgICAgIGNhbGxiYWNrKG5vdGVzKVxuICAgIH0pXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJybyBhbyBpbmljaWFyIGxpc3RlbmVyIGRlIG5vdGFzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9Ob3Rlcyh1c2VySWQ6IHN0cmluZywgY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vdGVzTGlzdGVuZXIobnVsbCwgKGFsbE5vdGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJOb3RlcyA9IGFsbE5vdGVzLmZpbHRlcihub3RlID0+IG5vdGUudXNlcklkID09PSB1c2VySWQgJiYgIVtcIlJBREFSXCIsIElORk9fQ0FURUdPUlldLmluY2x1ZGVzKG5vdGUuY2F0ZWdvcnkpKTtcbiAgICAgICAgY2FsbGJhY2sodXNlck5vdGVzKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvUmFkYXJOb3RlcyhjYWxsYmFjazogKG5vdGVzOiBOb3RlW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgcmV0dXJuIGNyZWF0ZU5vdGVzTGlzdGVuZXIoXCJSQURBUlwiLCBjYWxsYmFjaylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvSW5mb05vdGVzKGNhbGxiYWNrOiAobm90ZXM6IE5vdGVbXSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICByZXR1cm4gY3JlYXRlTm90ZXNMaXN0ZW5lcihJTkZPX0NBVEVHT1JZLCBjYWxsYmFjaylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZE5vdGUobm90ZURhdGE6IE9taXQ8Tm90ZSwgXCJpZFwiIHwgXCJjcmVhdGVkQXRcIiB8IFwidXBkYXRlZEF0XCI+KTogUHJvbWlzZTxOb3RlPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gIGNvbnN0IG5vdGVzUmVmID0gcmVmKGRiLCBDT0xMRUNUSU9OX05BTUUpXG4gIGNvbnN0IG5ld05vdGVSZWYgPSBwdXNoKG5vdGVzUmVmKVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgY29uc3QgbmV3Tm90ZSA9IHsgLi4ubm90ZURhdGEsIGNyZWF0ZWRBdDogbm93LCB1cGRhdGVkQXQ6IG5vdywgZGVsZXRlZDogZmFsc2UgfVxuICBhd2FpdCBzZXQobmV3Tm90ZVJlZiwgbmV3Tm90ZSlcbiAgcmV0dXJuIHsgaWQ6IG5ld05vdGVSZWYua2V5ISwgLi4ubmV3Tm90ZSB9IGFzIHVua25vd24gYXMgTm90ZVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlTm90ZShpZDogc3RyaW5nLCBub3RlRGF0YTogUGFydGlhbDxPbWl0PE5vdGUsIFwiaWRcIj4+LCB1cGRhdGVkQnk6IHN0cmluZywgdXBkYXRlZEJ5RGVwYXJ0bWVudDogRGVwYXJ0bWVudCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICBjb25zdCBub3RlUmVmID0gcmVmKGRiLCBgJHtDT0xMRUNUSU9OX05BTUV9LyR7aWR9YClcbiAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIGNvbnN0IHVwZGF0ZWREYXRhID0geyAuLi5ub3RlRGF0YSwgdXBkYXRlZEJ5LCB1cGRhdGVkQnlEZXBhcnRtZW50LCB1cGRhdGVkQXQgfVxuICBhd2FpdCB1cGRhdGUobm90ZVJlZiwgdXBkYXRlZERhdGEpXG59XG5cbi8vIDw8IENPUlJFw4fDg08gSU1QT1JUQU5URTogRnVuw6fDo28gYWx0ZXJhZGEgcGFyYSBmYXplciBcInNvZnQgZGVsZXRlXCJcbi8vIExvY2FsaXphw6fDo286IGxpYi9yZWFsdGltZS50c1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlTm90ZShpZDogc3RyaW5nLCB1cGRhdGVkQnk6IHN0cmluZywgdXBkYXRlZEJ5RGVwYXJ0bWVudDogRGVwYXJ0bWVudCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKTtcbiAgY29uc3Qgbm90ZVJlZiA9IHJlZihkYiwgYGFub3RhY29lcy8ke2lkfWApOyAvLyBQcmVwYXJhIGEgcmVmZXLDqm5jaWEgcGFyYSBvIGl0ZW0gZXNwZWPDrWZpY29cbiAgXG4gIC8vIERlZmluZSBvcyBjYW1wb3MgYSBzZXJlbSBhdHVhbGl6YWRvc1xuICBjb25zdCBmaWVsZHNUb1VwZGF0ZSA9IHtcbiAgICBkZWxldGVkOiB0cnVlLCAvLyBBcGVuYXMgbWFyY2EgbyBpdGVtIGNvbW8gYXBhZ2Fkb1xuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRCeSxcbiAgICB1cGRhdGVkQnlEZXBhcnRtZW50LFxuICB9O1xuXG4gIC8vIEVudmlhIGEgYXR1YWxpemHDp8OjbyBwYXJhIG8gRmlyZWJhc2VcbiAgYXdhaXQgdXBkYXRlKG5vdGVSZWYsIGZpZWxkc1RvVXBkYXRlKTsgXG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvZ2dsZU5vdGVDb21wbGV0ZWQoaWQ6IHN0cmluZywgY29tcGxldGVkOiBib29sZWFuLCB1cGRhdGVkQnk6IHN0cmluZywgdXBkYXRlZEJ5RGVwYXJ0bWVudDogRGVwYXJ0bWVudCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICBjb25zdCBub3RlUmVmID0gcmVmKGRiLCBgJHtDT0xMRUNUSU9OX05BTUV9LyR7aWR9YClcbiAgYXdhaXQgdXBkYXRlKG5vdGVSZWYsIHsgY29tcGxldGVkLCB1cGRhdGVkQnksIHVwZGF0ZWRCeURlcGFydG1lbnQsIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXG59XG5cbi8vIE8gcmVzdG8gZG8gZmljaGVpcm8gKGxpc3RlblRvU3RvcmFnZSwgc2F2ZVN0b3JhZ2VTZWxlY3Rpb24sIGV0Yy4pIHBlcm1hbmVjZSBpZ3VhbC4uLlxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvU3RvcmFnZShjYWxsYmFjazogKHN0b3JhZ2U6IFN0b3JhZ2VTZWxlY3Rpb24gfCBudWxsKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgICBjb25zdCBzdG9yYWdlUmVmID0gcmVmKGRiLCBgJHtTVE9SQUdFX0NPTExFQ1RJT059LyR7U1RPUkFHRV9ET0NfSUR9YClcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IG9uVmFsdWUoc3RvcmFnZVJlZiwgKHNuYXBzaG90KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKClcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhudWxsKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKHsgaWQ6IFNUT1JBR0VfRE9DX0lELCAuLi5kYXRhLCB1cGRhdGVkQXQ6IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KSB9KVxuICAgIH0pXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJybyBhbyBpbmljaWFyIGxpc3RlbmVyIGRlIGVzdG9jYWdlbTpcIiwgZXJyb3IpXG4gICAgcmV0dXJuICgpID0+IHt9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvU3RvcmFnZUxvZ3MoY2FsbGJhY2s6IChsb2dzOiBTdG9yYWdlTG9nW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICAgIGNvbnN0IGxvZ3NSZWYgPSByZWYoZGIsIFNUT1JBR0VfTE9HU19DT0xMRUNUSU9OKVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb25WYWx1ZShsb2dzUmVmLCAoc25hcHNob3QpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzbmFwc2hvdC52YWwoKVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrKFtdKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvZ3M6IFN0b3JhZ2VMb2dbXSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLm1hcCgoW2lkLCB2YWx1ZV06IGFueSkgPT4gKHtcbiAgICAgICAgaWQsXG4gICAgICAgIC4uLnZhbHVlLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHZhbHVlLnRpbWVzdGFtcCksXG4gICAgICB9KSlcbiAgICAgIGxvZ3Muc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpKVxuICAgICAgY2FsbGJhY2sobG9ncylcbiAgICB9KVxuICAgIHJldHVybiB1bnN1YnNjcmliZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm8gYW8gaW5pY2lhciBsaXN0ZW5lciBkZSBsb2dzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVN0b3JhZ2VTZWxlY3Rpb24oc2VsZWN0aW9uOiBPbWl0PFN0b3JhZ2VTZWxlY3Rpb24sIFwiaWRcIiB8IFwidXBkYXRlZEF0XCI+ICYgeyB1cGRhdGVkQnk6IHN0cmluZzsgdXBkYXRlZEJ5RGVwYXJ0bWVudDogRGVwYXJ0bWVudCB9KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpO1xuICBjb25zdCB0aW1lc3RhbXBJU08gPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7IC8vIDw8LS0gR2VyYXIgYSBzdHJpbmcgSVNPXG4gIGNvbnN0IHN0b3JhZ2VSZWYgPSByZWYoZGIsIGAke1NUT1JBR0VfQ09MTEVDVElPTn0vJHtTVE9SQUdFX0RPQ19JRH1gKTtcblxuICBjb25zdCBkYXRhVG9TYXZlID0ge1xuICAgIHRlZ1JvYWQ6IHNlbGVjdGlvbi50ZWdSb2FkLFxuICAgIHRlZ1JvYWRUb21iYWRvcjogc2VsZWN0aW9uLnRlZ1JvYWRUb21iYWRvcixcbiAgICB0ZWdSYWlsd2F5TW9lZ2EwMTogc2VsZWN0aW9uLnRlZ1JhaWx3YXlNb2VnYTAxLFxuICAgIHRlZ1JhaWx3YXlNb2VnYTAyOiBzZWxlY3Rpb24udGVnUmFpbHdheU1vZWdhMDIsXG4gICAgdGVhZ1JvYWQ6IHNlbGVjdGlvbi50ZWFnUm9hZCxcbiAgICB0ZWFnUmFpbHdheTogc2VsZWN0aW9uLnRlYWdSYWlsd2F5LFxuICAgIHVwZGF0ZWRCeTogc2VsZWN0aW9uLnVwZGF0ZWRCeSxcbiAgICB1cGRhdGVkQnlEZXBhcnRtZW50OiBzZWxlY3Rpb24udXBkYXRlZEJ5RGVwYXJ0bWVudCxcbiAgICB1cGRhdGVkQXQ6IHRpbWVzdGFtcElTTyBhcyBhbnksIC8vIDw8LS0gVXNhciBhIHN0cmluZyBJU08gZSBjb250b3JuYXIgYSB2ZXJpZmljYcOnw6NvIGRlIHRpcG9cbiAgfTtcblxuICBhd2FpdCBzZXQoc3RvcmFnZVJlZiwgZGF0YVRvU2F2ZSk7XG5cbiAgY29uc3QgbG9nUmVmID0gcHVzaChyZWYoZGIsIFNUT1JBR0VfTE9HU19DT0xMRUNUSU9OKSk7XG4gIGNvbnN0IG5ld0xvZzogT21pdDxTdG9yYWdlTG9nLCBcImlkXCI+ID0ge1xuICAgIGNoYW5nZWRCeTogc2VsZWN0aW9uLnVwZGF0ZWRCeSxcbiAgICBkZXBhcnRtZW50OiBzZWxlY3Rpb24udXBkYXRlZEJ5RGVwYXJ0bWVudCxcbiAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcElTTyBhcyBhbnksIC8vIDw8LS0gVXNhciBhIHN0cmluZyBJU08gZSBjb250b3JuYXIgYSB2ZXJpZmljYcOnw6NvIGRlIHRpcG9cbiAgICBjaGFuZ2VzOiB7XG4gICAgICB0ZWdSb2FkOiBzZWxlY3Rpb24udGVnUm9hZCxcbiAgICAgIHRlZ1JvYWRUb21iYWRvcjogc2VsZWN0aW9uLnRlZ1JvYWRUb21iYWRvcixcbiAgICAgIHRlZ1JhaWx3YXlNb2VnYTAxOiBzZWxlY3Rpb24udGVnUmFpbHdheU1vZWdhMDEsXG4gICAgICB0ZWdSYWlsd2F5TW9lZ2EwMjogc2VsZWN0aW9uLnRlZ1JhaWx3YXlNb2VnYTAyLFxuICAgICAgdGVhZ1JvYWQ6IHNlbGVjdGlvbi50ZWFnUm9hZCxcbiAgICAgIHRlYWdSYWlsd2F5OiBzZWxlY3Rpb24udGVhZ1JhaWx3YXksXG4gICAgfSxcbiAgfTtcbiAgYXdhaXQgc2V0KGxvZ1JlZiwgbmV3TG9nKTtcbn1cblxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZU9yVXBkYXRlVXNlcih1c2VyOiBVc2VyKTogUHJvbWlzZTx2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKCk7XG4gICAgY29uc3QgdXNlclJlZiA9IHJlZihkYiwgYCR7VVNFUlNfQ09MTEVDVElPTn0vJHt1c2VyLmlkfWApO1xuICAgIFxuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0KHVzZXJSZWYpO1xuICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IHNuYXBzaG90LnZhbCgpO1xuXG4gICAgY29uc3QgdXNlckRhdGEgPSB7XG4gICAgICB1c2VybmFtZTogdXNlci51c2VybmFtZSxcbiAgICAgIHBhc3N3b3JkOiB1c2VyLnBhc3N3b3JkIHx8IFwiXCIsXG4gICAgICByb2xlOiB1c2VyLnJvbGUsXG4gICAgICBkZXBhcnRtZW50OiB1c2VyLmRlcGFydG1lbnQsXG4gICAgICBsYXN0TG9naW46IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9O1xuXG4gICAgYXdhaXQgc2V0KHVzZXJSZWYsIHVzZXJEYXRhKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW3YwXSBFcnJvIGFvIHNhbHZhciB1c3XDoXJpbyBubyBiYW5jbzpcIiwgZXJyb3IpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVVzZXIodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKTtcbiAgICBjb25zdCB1c2Vyc1JlZiA9IHJlZihkYiwgVVNFUlNfQ09MTEVDVElPTik7XG4gICAgY29uc3Qgc25hcHNob3QgPSBhd2FpdCBnZXQodXNlcnNSZWYpO1xuICAgIGNvbnN0IGRhdGEgPSBzbmFwc2hvdC52YWwoKTtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgdXNlckVudHJ5ID0gT2JqZWN0LmVudHJpZXMoZGF0YSkuZmluZCgoWywgdmFsdWVdOiBhbnkpID0+IFxuICAgICAgICB2YWx1ZS51c2VybmFtZSA9PT0gdXNlcm5hbWUgJiYgdmFsdWUucGFzc3dvcmQgPT09IHBhc3N3b3JkXG4gICAgKTtcblxuICAgIGlmICghdXNlckVudHJ5KSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IFtpZCwgdmFsdWVdOiBhbnkgPSB1c2VyRW50cnk7XG4gICAgY29uc3QgdXNlcjogVXNlciA9IHsgaWQsIC4uLnZhbHVlIH07XG5cbiAgICBjb25zdCB1c2VyUmVmID0gcmVmKGRiLCBgJHtVU0VSU19DT0xMRUNUSU9OfS8ke2lkfWApO1xuICAgIHVwZGF0ZSh1c2VyUmVmLCB7IGxhc3RMb2dpbjogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pO1xuXG4gICAgcmV0dXJuIHVzZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm8gYW8gdmFsaWRhciB1c3XDoXJpbzpcIiwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxVc2VycygpOiBQcm9taXNlPFVzZXJbXT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpO1xuICAgICAgICBjb25zdCB1c2Vyc1JlZiA9IHJlZihkYiwgVVNFUlNfQ09MTEVDVElPTik7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0KHVzZXJzUmVmKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHNuYXBzaG90LnZhbCgpO1xuICAgICAgICBpZiAoIWRhdGEpIHJldHVybiBbXTtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGF0YSkubWFwKChbaWQsIHZhbHVlXTogYW55KSA9PiAoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAuLi52YWx1ZVxuICAgICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm8gYW8gYnVzY2FyIHVzdcOhcmlvczpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbInJlZiIsIm9uVmFsdWUiLCJzZXQiLCJwdXNoIiwidXBkYXRlIiwiZ2V0IiwiZ2V0RmlyZWJhc2VEYXRhYmFzZSIsIklORk9fQ0FURUdPUlkiLCJDT0xMRUNUSU9OX05BTUUiLCJTVE9SQUdFX0NPTExFQ1RJT04iLCJTVE9SQUdFX0xPR1NfQ09MTEVDVElPTiIsIlNUT1JBR0VfRE9DX0lEIiwiVVNFUlNfQ09MTEVDVElPTiIsImlzRmlyZWJhc2VDb25maWd1cmVkIiwiaGFzQXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQSV9LRVkiLCJoYXNQcm9qZWN0SWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9QUk9KRUNUX0lEIiwiaGFzRGF0YWJhc2VVcmwiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9EQVRBQkFTRV9VUkwiLCJnZXRDb25maWdFcnJvck1lc3NhZ2UiLCJtaXNzaW5nIiwiam9pbiIsImNyZWF0ZU5vdGVzTGlzdGVuZXIiLCJjYXRlZ29yeSIsImNhbGxiYWNrIiwiZGIiLCJub3Rlc1JlZiIsInVuc3Vic2NyaWJlIiwic25hcHNob3QiLCJkYXRhIiwidmFsIiwibm90ZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwiaWQiLCJ2YWx1ZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3ciLCJ1cGRhdGVkQXQiLCJmaWx0ZXIiLCJub3RlIiwiZGVsZXRlZCIsInNvcnQiLCJhIiwiYiIsImdldFRpbWUiLCJlcnJvciIsImNvbnNvbGUiLCJsaXN0ZW5Ub05vdGVzIiwidXNlcklkIiwiYWxsTm90ZXMiLCJ1c2VyTm90ZXMiLCJpbmNsdWRlcyIsImxpc3RlblRvUmFkYXJOb3RlcyIsImxpc3RlblRvSW5mb05vdGVzIiwiYWRkTm90ZSIsIm5vdGVEYXRhIiwibmV3Tm90ZVJlZiIsInRvSVNPU3RyaW5nIiwibmV3Tm90ZSIsImtleSIsInVwZGF0ZU5vdGUiLCJ1cGRhdGVkQnkiLCJ1cGRhdGVkQnlEZXBhcnRtZW50Iiwibm90ZVJlZiIsInVwZGF0ZWREYXRhIiwiZGVsZXRlTm90ZSIsImZpZWxkc1RvVXBkYXRlIiwidG9nZ2xlTm90ZUNvbXBsZXRlZCIsImNvbXBsZXRlZCIsImxpc3RlblRvU3RvcmFnZSIsInN0b3JhZ2VSZWYiLCJsaXN0ZW5Ub1N0b3JhZ2VMb2dzIiwibG9nc1JlZiIsImxvZ3MiLCJ0aW1lc3RhbXAiLCJzYXZlU3RvcmFnZVNlbGVjdGlvbiIsInNlbGVjdGlvbiIsInRpbWVzdGFtcElTTyIsImRhdGFUb1NhdmUiLCJ0ZWdSb2FkIiwidGVnUm9hZFRvbWJhZG9yIiwidGVnUmFpbHdheU1vZWdhMDEiLCJ0ZWdSYWlsd2F5TW9lZ2EwMiIsInRlYWdSb2FkIiwidGVhZ1JhaWx3YXkiLCJsb2dSZWYiLCJuZXdMb2ciLCJjaGFuZ2VkQnkiLCJkZXBhcnRtZW50IiwiY2hhbmdlcyIsInNhdmVPclVwZGF0ZVVzZXIiLCJ1c2VyIiwidXNlclJlZiIsImV4aXN0aW5nVXNlciIsInVzZXJEYXRhIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInJvbGUiLCJsYXN0TG9naW4iLCJ2YWxpZGF0ZVVzZXIiLCJ1c2Vyc1JlZiIsInVzZXJFbnRyeSIsImZpbmQiLCJnZXRBbGxVc2VycyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/realtime.ts\n"));

/***/ })

});