"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/realtime.ts":
/*!*************************!*\
  !*** ./lib/realtime.ts ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addNote: () => (/* binding */ addNote),\n/* harmony export */   deleteNote: () => (/* binding */ deleteNote),\n/* harmony export */   getAllUsers: () => (/* binding */ getAllUsers),\n/* harmony export */   getConfigErrorMessage: () => (/* binding */ getConfigErrorMessage),\n/* harmony export */   isFirebaseConfigured: () => (/* binding */ isFirebaseConfigured),\n/* harmony export */   listenToInfoNotes: () => (/* binding */ listenToInfoNotes),\n/* harmony export */   listenToNotes: () => (/* binding */ listenToNotes),\n/* harmony export */   listenToRadarNotes: () => (/* binding */ listenToRadarNotes),\n/* harmony export */   listenToStorage: () => (/* binding */ listenToStorage),\n/* harmony export */   listenToStorageLogs: () => (/* binding */ listenToStorageLogs),\n/* harmony export */   saveOrUpdateUser: () => (/* binding */ saveOrUpdateUser),\n/* harmony export */   saveStorageSelection: () => (/* binding */ saveStorageSelection),\n/* harmony export */   toggleNoteCompleted: () => (/* binding */ toggleNoteCompleted),\n/* harmony export */   updateNote: () => (/* binding */ updateNote),\n/* harmony export */   validateUser: () => (/* binding */ validateUser)\n/* harmony export */ });\n/* harmony import */ var firebase_database__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/database */ \"(app-pages-browser)/./node_modules/firebase/database/dist/esm/index.esm.js\");\n/* harmony import */ var _firebase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firebase */ \"(app-pages-browser)/./lib/firebase.ts\");\n/* harmony import */ var _types_note__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/types/note */ \"(app-pages-browser)/./types/note.ts\");\n/* __next_internal_client_entry_do_not_use__ isFirebaseConfigured,getConfigErrorMessage,listenToNotes,listenToRadarNotes,listenToInfoNotes,addNote,updateNote,deleteNote,toggleNoteCompleted,listenToStorage,listenToStorageLogs,saveStorageSelection,saveOrUpdateUser,validateUser,getAllUsers auto */ \n\n\nconst COLLECTION_NAME = \"anotacoes\";\nconst STORAGE_COLLECTION = \"estocagem\";\nconst STORAGE_LOGS_COLLECTION = \"storage_logs\";\nconst STORAGE_DOC_ID = \"current\";\nconst USERS_COLLECTION = \"usuarios\";\nfunction isFirebaseConfigured() {\n    const hasApiKey = !!\"AIzaSyDjfV9hL9nu3cIQfVV8Yj7IdDnpZBtLY18\";\n    const hasProjectId = !!\"1:441739339291:web:597e21e95626a979cababe\";\n    const hasDatabaseUrl = !!\"https://anotacoes-ecc99-default-rtdb.firebaseio.com\";\n    return hasApiKey && hasProjectId && hasDatabaseUrl;\n}\nfunction getConfigErrorMessage() {\n    const missing = [];\n    if (false) {}\n    if (false) {}\n    if (false) {}\n    return \"Vari\\xe1veis de ambiente faltando: \".concat(missing.join(\", \"));\n}\nfunction createNotesListener(category, callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const notesRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, COLLECTION_NAME);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(notesRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            let notes = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    ...value,\n                    createdAt: new Date(value.createdAt || Date.now()),\n                    updatedAt: new Date(value.updatedAt || Date.now())\n                };\n            }).filter((note)=>!note.deleted) // << CORREÇÃO IMPORTANTE: Garante que notas \"apagadas\" não apareçam\n            ;\n            if (category) {\n                notes = notes.filter((note)=>note.category === category);\n            }\n            notes.sort((a, b)=>b.createdAt.getTime() - a.createdAt.getTime());\n            callback(notes);\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de notas:\", error);\n        return ()=>{};\n    }\n}\nfunction listenToNotes(userId, callback) {\n    return createNotesListener(null, (allNotes)=>{\n        const userNotes = allNotes.filter((note)=>note.userId === userId && ![\n                \"RADAR\",\n                _types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY\n            ].includes(note.category));\n        callback(userNotes);\n    });\n}\nfunction listenToRadarNotes(callback) {\n    return createNotesListener(\"RADAR\", callback);\n}\nfunction listenToInfoNotes(callback) {\n    return createNotesListener(_types_note__WEBPACK_IMPORTED_MODULE_2__.INFO_CATEGORY, callback);\n}\nasync function addNote(noteData) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const notesRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, COLLECTION_NAME);\n    const newNoteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)(notesRef);\n    const now = new Date().toISOString();\n    const newNote = {\n        ...noteData,\n        createdAt: now,\n        updatedAt: now,\n        deleted: false\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(newNoteRef, newNote);\n    return {\n        id: newNoteRef.key,\n        ...newNote\n    };\n}\nasync function updateNote(id, noteData, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(COLLECTION_NAME, \"/\").concat(id));\n    const updatedAt = new Date().toISOString();\n    const updatedData = {\n        ...noteData,\n        updatedBy,\n        updatedByDepartment,\n        updatedAt\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, updatedData);\n}\n// << CORREÇÃO IMPORTANTE: Função alterada para fazer \"soft delete\"\n// Localização: lib/realtime.ts\nasync function deleteNote(id, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"anotacoes/\".concat(id)); // Prepara a referência para o item específico\n    // Define os campos a serem atualizados\n    const fieldsToUpdate = {\n        deleted: true,\n        updatedAt: new Date().toISOString(),\n        updatedBy,\n        updatedByDepartment\n    };\n    // Envia a atualização para o Firebase\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, fieldsToUpdate);\n}\nasync function toggleNoteCompleted(id, completed, updatedBy, updatedByDepartment) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const noteRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(COLLECTION_NAME, \"/\").concat(id));\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(noteRef, {\n        completed,\n        updatedBy,\n        updatedByDepartment,\n        updatedAt: new Date().toISOString()\n    });\n}\n// O resto do ficheiro (listenToStorage, saveStorageSelection, etc.) permanece igual...\nfunction listenToStorage(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const storageRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(STORAGE_COLLECTION, \"/\").concat(STORAGE_DOC_ID));\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(storageRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback(null);\n                return;\n            }\n            callback({\n                id: STORAGE_DOC_ID,\n                ...data,\n                updatedAt: new Date(data.updatedAt)\n            });\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de estocagem:\", error);\n        return ()=>{};\n    }\n}\nfunction listenToStorageLogs(callback) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const logsRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, STORAGE_LOGS_COLLECTION);\n        const unsubscribe = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.onValue)(logsRef, (snapshot)=>{\n            const data = snapshot.val();\n            if (!data) {\n                callback([]);\n                return;\n            }\n            const logs = Object.entries(data).map((param)=>{\n                let [id, value] = param;\n                return {\n                    id,\n                    ...value,\n                    timestamp: new Date(value.timestamp)\n                };\n            });\n            logs.sort((a, b)=>b.timestamp.getTime() - a.timestamp.getTime());\n            callback(logs);\n        });\n        return unsubscribe;\n    } catch (error) {\n        console.error(\"[v0] Erro ao iniciar listener de logs:\", error);\n        return ()=>{};\n    }\n}\nasync function saveStorageSelection(selection) {\n    const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n    const timestamp = new Date() // Objeto Date\n    ;\n    const storageRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(STORAGE_COLLECTION, \"/\").concat(STORAGE_DOC_ID));\n    // CORREÇÃO: Usar o objeto 'timestamp' diretamente para respeitar o tipo Date\n    const updatedSelection = {\n        ...selection,\n        updatedAt: timestamp\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(storageRef, updatedSelection);\n    const logRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.push)((0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, STORAGE_LOGS_COLLECTION));\n    const newLog = {\n        changedBy: selection.updatedBy,\n        department: selection.updatedByDepartment,\n        // CORREÇÃO: Usar o objeto 'timestamp' diretamente para respeitar o tipo Date\n        timestamp: timestamp,\n        changes: {\n            tegRoad: selection.tegRoad,\n            tegRoadTombador: selection.tegRoadTombador,\n            tegRailwayMoega01: selection.tegRailwayMoega01,\n            tegRailwayMoega02: selection.tegRailwayMoega02,\n            teagRoad: selection.teagRoad,\n            teagRailway: selection.teagRailway\n        }\n    };\n    await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(logRef, newLog);\n}\nasync function saveOrUpdateUser(user) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const userRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(USERS_COLLECTION, \"/\").concat(user.id));\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(userRef);\n        const existingUser = snapshot.val();\n        const userData = {\n            username: user.username,\n            password: user.password || \"\",\n            role: user.role,\n            department: user.department,\n            lastLogin: new Date().toISOString()\n        };\n        await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.set)(userRef, userData);\n    } catch (error) {\n        console.error(\"[v0] Erro ao salvar usuário no banco:\", error);\n    }\n}\nasync function validateUser(username, password) {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const usersRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, USERS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(usersRef);\n        const data = snapshot.val();\n        if (!data) return null;\n        const userEntry = Object.entries(data).find((param)=>{\n            let [, value] = param;\n            return value.username === username && value.password === password;\n        });\n        if (!userEntry) return null;\n        const [id, value] = userEntry;\n        const user = {\n            id,\n            ...value\n        };\n        const userRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, \"\".concat(USERS_COLLECTION, \"/\").concat(id));\n        (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.update)(userRef, {\n            lastLogin: new Date().toISOString()\n        });\n        return user;\n    } catch (error) {\n        console.error(\"Erro ao validar usuário:\", error);\n        return null;\n    }\n}\nasync function getAllUsers() {\n    try {\n        const db = (0,_firebase__WEBPACK_IMPORTED_MODULE_1__.getFirebaseDatabase)();\n        const usersRef = (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.ref)(db, USERS_COLLECTION);\n        const snapshot = await (0,firebase_database__WEBPACK_IMPORTED_MODULE_0__.get)(usersRef);\n        const data = snapshot.val();\n        if (!data) return [];\n        return Object.entries(data).map((param)=>{\n            let [id, value] = param;\n            return {\n                id,\n                ...value\n            };\n        });\n    } catch (error) {\n        console.error(\"Erro ao buscar usuários:\", error);\n        return [];\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFBRTFEO1lBQUksR0FBR0MsS0FBSztRQUFDO1FBRWxDLE1BQU0wRCxVQUFVakcsc0RBQUdBLENBQUM0QixJQUFJLEdBQXVCVSxPQUFwQjFCLGtCQUFpQixLQUFNLE9BQUgwQjtRQUMvQ2xDLHlEQUFNQSxDQUFDNkYsU0FBUztZQUFFTSxXQUFXLElBQUk5RCxPQUFPc0IsV0FBVztRQUFHO1FBRXRELE9BQU9pQztJQUNULEVBQUUsT0FBTzdDLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsT0FBTztJQUNUO0FBQ0Y7QUFFTyxlQUFleUQ7SUFDbEIsSUFBSTtRQUNBLE1BQU1oRixLQUFLdEIsOERBQW1CQTtRQUM5QixNQUFNbUcsV0FBV3pHLHNEQUFHQSxDQUFDNEIsSUFBSWhCO1FBQ3pCLE1BQU1tQixXQUFXLE1BQU0xQixzREFBR0EsQ0FBQ29HO1FBQzNCLE1BQU16RSxPQUFPRCxTQUFTRSxHQUFHO1FBQ3pCLElBQUksQ0FBQ0QsTUFBTSxPQUFPLEVBQUU7UUFFcEIsT0FBT0csT0FBT0MsT0FBTyxDQUFDSixNQUFNSyxHQUFHLENBQUM7Z0JBQUMsQ0FBQ0MsSUFBSUMsTUFBVzttQkFBTTtnQkFDbkREO2dCQUNBLEdBQUdDLEtBQUs7WUFDWjs7SUFDSixFQUFFLE9BQU9ZLE9BQU87UUFDWkMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsT0FBTyxFQUFFO0lBQ2I7QUFDSiIsInNvdXJjZXMiOlsiL2hvbWUvdXNlci9ub3RlL2xpYi9yZWFsdGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgeyByZWYsIG9uVmFsdWUsIHNldCwgcHVzaCwgdXBkYXRlLCBnZXQgfSBmcm9tIFwiZmlyZWJhc2UvZGF0YWJhc2VcIlxuaW1wb3J0IHsgZ2V0RmlyZWJhc2VEYXRhYmFzZSB9IGZyb20gXCIuL2ZpcmViYXNlXCJcbmltcG9ydCB0eXBlIHsgTm90ZSwgQ2F0ZWdvcnkgfSBmcm9tIFwiQC90eXBlcy9ub3RlXCJcbmltcG9ydCB7IElORk9fQ0FURUdPUlkgfSBmcm9tIFwiQC90eXBlcy9ub3RlXCJcbmltcG9ydCB0eXBlIHsgVXNlciwgRGVwYXJ0bWVudCB9IGZyb20gXCJAL3R5cGVzL3VzZXJcIlxuaW1wb3J0IHR5cGUgeyBTdG9yYWdlU2VsZWN0aW9uLCBTdG9yYWdlTG9nIH0gZnJvbSBcIkAvdHlwZXMvc3RvcmFnZVwiXG5cbmNvbnN0IENPTExFQ1RJT05fTkFNRSA9IFwiYW5vdGFjb2VzXCJcbmNvbnN0IFNUT1JBR0VfQ09MTEVDVElPTiA9IFwiZXN0b2NhZ2VtXCJcbmNvbnN0IFNUT1JBR0VfTE9HU19DT0xMRUNUSU9OID0gXCJzdG9yYWdlX2xvZ3NcIlxuY29uc3QgU1RPUkFHRV9ET0NfSUQgPSBcImN1cnJlbnRcIlxuY29uc3QgVVNFUlNfQ09MTEVDVElPTiA9IFwidXN1YXJpb3NcIlxuXG5leHBvcnQgZnVuY3Rpb24gaXNGaXJlYmFzZUNvbmZpZ3VyZWQoKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhhc0FwaUtleSA9ICEhcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWVxuICBjb25zdCBoYXNQcm9qZWN0SWQgPSAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSURcbiAgY29uc3QgaGFzRGF0YWJhc2VVcmwgPSAhIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0RBVEFCQVNFX1VSTFxuICByZXR1cm4gaGFzQXBpS2V5ICYmIGhhc1Byb2plY3RJZCAmJiBoYXNEYXRhYmFzZVVybFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29uZmlnRXJyb3JNZXNzYWdlKCk6IHN0cmluZyB7XG4gIGNvbnN0IG1pc3Npbmc6IHN0cmluZ1tdID0gW11cbiAgaWYgKCFwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZKSBtaXNzaW5nLnB1c2goXCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZXCIpXG4gIGlmICghcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCkgbWlzc2luZy5wdXNoKFwiTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRFwiKVxuICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0RBVEFCQVNFX1VSTCkgbWlzc2luZy5wdXNoKFwiTkVYVF9QVUJMSUNfRklSRUJBU0VfREFUQUJBU0VfVVJMXCIpXG4gIHJldHVybiBgVmFyacOhdmVpcyBkZSBhbWJpZW50ZSBmYWx0YW5kbzogJHttaXNzaW5nLmpvaW4oXCIsIFwiKX1gXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vdGVzTGlzdGVuZXIoY2F0ZWdvcnk6IENhdGVnb3J5IHwgc3RyaW5nIHwgbnVsbCwgY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgICBjb25zdCBub3Rlc1JlZiA9IHJlZihkYiwgQ09MTEVDVElPTl9OQU1FKVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb25WYWx1ZShub3Rlc1JlZiwgKHNuYXBzaG90KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKClcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhbXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBsZXQgbm90ZXM6IE5vdGVbXSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpXG4gICAgICAgIC5tYXAoKFtpZCwgdmFsdWVdOiBhbnkpID0+ICh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSh2YWx1ZS5jcmVhdGVkQXQgfHwgRGF0ZS5ub3coKSksXG4gICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSh2YWx1ZS51cGRhdGVkQXQgfHwgRGF0ZS5ub3coKSksXG4gICAgICAgIH0pKVxuICAgICAgICAuZmlsdGVyKG5vdGUgPT4gIW5vdGUuZGVsZXRlZCkgLy8gPDwgQ09SUkXDh8ODTyBJTVBPUlRBTlRFOiBHYXJhbnRlIHF1ZSBub3RhcyBcImFwYWdhZGFzXCIgbsOjbyBhcGFyZcOnYW1cblxuICAgICAgaWYgKGNhdGVnb3J5KSB7XG4gICAgICAgIG5vdGVzID0gbm90ZXMuZmlsdGVyKChub3RlKSA9PiBub3RlLmNhdGVnb3J5ID09PSBjYXRlZ29yeSlcbiAgICAgIH1cbiAgICAgIG5vdGVzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZEF0LmdldFRpbWUoKSAtIGEuY3JlYXRlZEF0LmdldFRpbWUoKSlcbiAgICAgIGNhbGxiYWNrKG5vdGVzKVxuICAgIH0pXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJybyBhbyBpbmljaWFyIGxpc3RlbmVyIGRlIG5vdGFzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuVG9Ob3Rlcyh1c2VySWQ6IHN0cmluZywgY2FsbGJhY2s6IChub3RlczogTm90ZVtdKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vdGVzTGlzdGVuZXIobnVsbCwgKGFsbE5vdGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJOb3RlcyA9IGFsbE5vdGVzLmZpbHRlcihub3RlID0+IG5vdGUudXNlcklkID09PSB1c2VySWQgJiYgIVtcIlJBREFSXCIsIElORk9fQ0FURUdPUlldLmluY2x1ZGVzKG5vdGUuY2F0ZWdvcnkpKTtcbiAgICAgICAgY2FsbGJhY2sodXNlck5vdGVzKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvUmFkYXJOb3RlcyhjYWxsYmFjazogKG5vdGVzOiBOb3RlW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgcmV0dXJuIGNyZWF0ZU5vdGVzTGlzdGVuZXIoXCJSQURBUlwiLCBjYWxsYmFjaylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvSW5mb05vdGVzKGNhbGxiYWNrOiAobm90ZXM6IE5vdGVbXSkgPT4gdm9pZCk6ICgpID0+IHZvaWQge1xuICByZXR1cm4gY3JlYXRlTm90ZXNMaXN0ZW5lcihJTkZPX0NBVEVHT1JZLCBjYWxsYmFjaylcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFkZE5vdGUobm90ZURhdGE6IE9taXQ8Tm90ZSwgXCJpZFwiIHwgXCJjcmVhdGVkQXRcIiB8IFwidXBkYXRlZEF0XCI+KTogUHJvbWlzZTxOb3RlPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gIGNvbnN0IG5vdGVzUmVmID0gcmVmKGRiLCBDT0xMRUNUSU9OX05BTUUpXG4gIGNvbnN0IG5ld05vdGVSZWYgPSBwdXNoKG5vdGVzUmVmKVxuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgY29uc3QgbmV3Tm90ZSA9IHsgLi4ubm90ZURhdGEsIGNyZWF0ZWRBdDogbm93LCB1cGRhdGVkQXQ6IG5vdywgZGVsZXRlZDogZmFsc2UgfVxuICBhd2FpdCBzZXQobmV3Tm90ZVJlZiwgbmV3Tm90ZSlcbiAgcmV0dXJuIHsgaWQ6IG5ld05vdGVSZWYua2V5ISwgLi4ubmV3Tm90ZSB9IGFzIHVua25vd24gYXMgTm90ZVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlTm90ZShpZDogc3RyaW5nLCBub3RlRGF0YTogUGFydGlhbDxPbWl0PE5vdGUsIFwiaWRcIj4+LCB1cGRhdGVkQnk6IHN0cmluZywgdXBkYXRlZEJ5RGVwYXJ0bWVudDogRGVwYXJ0bWVudCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICBjb25zdCBub3RlUmVmID0gcmVmKGRiLCBgJHtDT0xMRUNUSU9OX05BTUV9LyR7aWR9YClcbiAgY29uc3QgdXBkYXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gIGNvbnN0IHVwZGF0ZWREYXRhID0geyAuLi5ub3RlRGF0YSwgdXBkYXRlZEJ5LCB1cGRhdGVkQnlEZXBhcnRtZW50LCB1cGRhdGVkQXQgfVxuICBhd2FpdCB1cGRhdGUobm90ZVJlZiwgdXBkYXRlZERhdGEpXG59XG5cbi8vIDw8IENPUlJFw4fDg08gSU1QT1JUQU5URTogRnVuw6fDo28gYWx0ZXJhZGEgcGFyYSBmYXplciBcInNvZnQgZGVsZXRlXCJcbi8vIExvY2FsaXphw6fDo286IGxpYi9yZWFsdGltZS50c1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlTm90ZShpZDogc3RyaW5nLCB1cGRhdGVkQnk6IHN0cmluZywgdXBkYXRlZEJ5RGVwYXJ0bWVudDogRGVwYXJ0bWVudCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKTtcbiAgY29uc3Qgbm90ZVJlZiA9IHJlZihkYiwgYGFub3RhY29lcy8ke2lkfWApOyAvLyBQcmVwYXJhIGEgcmVmZXLDqm5jaWEgcGFyYSBvIGl0ZW0gZXNwZWPDrWZpY29cbiAgXG4gIC8vIERlZmluZSBvcyBjYW1wb3MgYSBzZXJlbSBhdHVhbGl6YWRvc1xuICBjb25zdCBmaWVsZHNUb1VwZGF0ZSA9IHtcbiAgICBkZWxldGVkOiB0cnVlLCAvLyBBcGVuYXMgbWFyY2EgbyBpdGVtIGNvbW8gYXBhZ2Fkb1xuICAgIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIHVwZGF0ZWRCeSxcbiAgICB1cGRhdGVkQnlEZXBhcnRtZW50LFxuICB9O1xuXG4gIC8vIEVudmlhIGEgYXR1YWxpemHDp8OjbyBwYXJhIG8gRmlyZWJhc2VcbiAgYXdhaXQgdXBkYXRlKG5vdGVSZWYsIGZpZWxkc1RvVXBkYXRlKTsgXG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvZ2dsZU5vdGVDb21wbGV0ZWQoaWQ6IHN0cmluZywgY29tcGxldGVkOiBib29sZWFuLCB1cGRhdGVkQnk6IHN0cmluZywgdXBkYXRlZEJ5RGVwYXJ0bWVudDogRGVwYXJ0bWVudCk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICBjb25zdCBub3RlUmVmID0gcmVmKGRiLCBgJHtDT0xMRUNUSU9OX05BTUV9LyR7aWR9YClcbiAgYXdhaXQgdXBkYXRlKG5vdGVSZWYsIHsgY29tcGxldGVkLCB1cGRhdGVkQnksIHVwZGF0ZWRCeURlcGFydG1lbnQsIHVwZGF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpIH0pXG59XG5cbi8vIE8gcmVzdG8gZG8gZmljaGVpcm8gKGxpc3RlblRvU3RvcmFnZSwgc2F2ZVN0b3JhZ2VTZWxlY3Rpb24sIGV0Yy4pIHBlcm1hbmVjZSBpZ3VhbC4uLlxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvU3RvcmFnZShjYWxsYmFjazogKHN0b3JhZ2U6IFN0b3JhZ2VTZWxlY3Rpb24gfCBudWxsKSA9PiB2b2lkKTogKCkgPT4gdm9pZCB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKClcbiAgICBjb25zdCBzdG9yYWdlUmVmID0gcmVmKGRiLCBgJHtTVE9SQUdFX0NPTExFQ1RJT059LyR7U1RPUkFHRV9ET0NfSUR9YClcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9IG9uVmFsdWUoc3RvcmFnZVJlZiwgKHNuYXBzaG90KSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKClcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBjYWxsYmFjayhudWxsKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKHsgaWQ6IFNUT1JBR0VfRE9DX0lELCAuLi5kYXRhLCB1cGRhdGVkQXQ6IG5ldyBEYXRlKGRhdGEudXBkYXRlZEF0KSB9KVxuICAgIH0pXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJybyBhbyBpbmljaWFyIGxpc3RlbmVyIGRlIGVzdG9jYWdlbTpcIiwgZXJyb3IpXG4gICAgcmV0dXJuICgpID0+IHt9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlblRvU3RvcmFnZUxvZ3MoY2FsbGJhY2s6IChsb2dzOiBTdG9yYWdlTG9nW10pID0+IHZvaWQpOiAoKSA9PiB2b2lkIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKVxuICAgIGNvbnN0IGxvZ3NSZWYgPSByZWYoZGIsIFNUT1JBR0VfTE9HU19DT0xMRUNUSU9OKVxuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gb25WYWx1ZShsb2dzUmVmLCAoc25hcHNob3QpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzbmFwc2hvdC52YWwoKVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrKFtdKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvZ3M6IFN0b3JhZ2VMb2dbXSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLm1hcCgoW2lkLCB2YWx1ZV06IGFueSkgPT4gKHtcbiAgICAgICAgaWQsXG4gICAgICAgIC4uLnZhbHVlLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKHZhbHVlLnRpbWVzdGFtcCksXG4gICAgICB9KSlcbiAgICAgIGxvZ3Muc29ydCgoYSwgYikgPT4gYi50aW1lc3RhbXAuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpKVxuICAgICAgY2FsbGJhY2sobG9ncylcbiAgICB9KVxuICAgIHJldHVybiB1bnN1YnNjcmliZVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbdjBdIEVycm8gYW8gaW5pY2lhciBsaXN0ZW5lciBkZSBsb2dzOlwiLCBlcnJvcilcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2F2ZVN0b3JhZ2VTZWxlY3Rpb24oc2VsZWN0aW9uOiBPbWl0PFN0b3JhZ2VTZWxlY3Rpb24sIFwiaWRcIiB8IFwidXBkYXRlZEF0XCI+ICYgeyB1cGRhdGVkQnk6IHN0cmluZzsgdXBkYXRlZEJ5RGVwYXJ0bWVudDogRGVwYXJ0bWVudCB9KTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpXG4gIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkgLy8gT2JqZXRvIERhdGVcbiAgY29uc3Qgc3RvcmFnZVJlZiA9IHJlZihkYiwgYCR7U1RPUkFHRV9DT0xMRUNUSU9OfS8ke1NUT1JBR0VfRE9DX0lEfWApXG4gIFxuICAvLyBDT1JSRcOHw4NPOiBVc2FyIG8gb2JqZXRvICd0aW1lc3RhbXAnIGRpcmV0YW1lbnRlIHBhcmEgcmVzcGVpdGFyIG8gdGlwbyBEYXRlXG4gIGNvbnN0IHVwZGF0ZWRTZWxlY3Rpb24gPSB7IC4uLnNlbGVjdGlvbiwgdXBkYXRlZEF0OiB0aW1lc3RhbXAgfVxuICBhd2FpdCBzZXQoc3RvcmFnZVJlZiwgdXBkYXRlZFNlbGVjdGlvbilcblxuICBjb25zdCBsb2dSZWYgPSBwdXNoKHJlZihkYiwgU1RPUkFHRV9MT0dTX0NPTExFQ1RJT04pKVxuICBjb25zdCBuZXdMb2c6IE9taXQ8U3RvcmFnZUxvZywgXCJpZFwiPiA9IHtcbiAgICBjaGFuZ2VkQnk6IHNlbGVjdGlvbi51cGRhdGVkQnksXG4gICAgZGVwYXJ0bWVudDogc2VsZWN0aW9uLnVwZGF0ZWRCeURlcGFydG1lbnQsXG4gICAgLy8gQ09SUkXDh8ODTzogVXNhciBvIG9iamV0byAndGltZXN0YW1wJyBkaXJldGFtZW50ZSBwYXJhIHJlc3BlaXRhciBvIHRpcG8gRGF0ZVxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLCBcbiAgICBjaGFuZ2VzOiB7XG4gICAgICB0ZWdSb2FkOiBzZWxlY3Rpb24udGVnUm9hZCxcbiAgICAgIHRlZ1JvYWRUb21iYWRvcjogc2VsZWN0aW9uLnRlZ1JvYWRUb21iYWRvcixcbiAgICAgIHRlZ1JhaWx3YXlNb2VnYTAxOiBzZWxlY3Rpb24udGVnUmFpbHdheU1vZWdhMDEsXG4gICAgICB0ZWdSYWlsd2F5TW9lZ2EwMjogc2VsZWN0aW9uLnRlZ1JhaWx3YXlNb2VnYTAyLFxuICAgICAgdGVhZ1JvYWQ6IHNlbGVjdGlvbi50ZWFnUm9hZCxcbiAgICAgIHRlYWdSYWlsd2F5OiBzZWxlY3Rpb24udGVhZ1JhaWx3YXksXG4gICAgfSxcbiAgfVxuICBhd2FpdCBzZXQobG9nUmVmLCBuZXdMb2cpXG59XG5cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNhdmVPclVwZGF0ZVVzZXIodXNlcjogVXNlcik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRiID0gZ2V0RmlyZWJhc2VEYXRhYmFzZSgpO1xuICAgIGNvbnN0IHVzZXJSZWYgPSByZWYoZGIsIGAke1VTRVJTX0NPTExFQ1RJT059LyR7dXNlci5pZH1gKTtcbiAgICBcbiAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldCh1c2VyUmVmKTtcbiAgICBjb25zdCBleGlzdGluZ1VzZXIgPSBzbmFwc2hvdC52YWwoKTtcblxuICAgIGNvbnN0IHVzZXJEYXRhID0ge1xuICAgICAgdXNlcm5hbWU6IHVzZXIudXNlcm5hbWUsXG4gICAgICBwYXNzd29yZDogdXNlci5wYXNzd29yZCB8fCBcIlwiLFxuICAgICAgcm9sZTogdXNlci5yb2xlLFxuICAgICAgZGVwYXJ0bWVudDogdXNlci5kZXBhcnRtZW50LFxuICAgICAgbGFzdExvZ2luOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcblxuICAgIGF3YWl0IHNldCh1c2VyUmVmLCB1c2VyRGF0YSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlt2MF0gRXJybyBhbyBzYWx2YXIgdXN1w6FyaW8gbm8gYmFuY286XCIsIGVycm9yKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVVc2VyKHVzZXJuYW1lOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPFVzZXIgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGIgPSBnZXRGaXJlYmFzZURhdGFiYXNlKCk7XG4gICAgY29uc3QgdXNlcnNSZWYgPSByZWYoZGIsIFVTRVJTX0NPTExFQ1RJT04pO1xuICAgIGNvbnN0IHNuYXBzaG90ID0gYXdhaXQgZ2V0KHVzZXJzUmVmKTtcbiAgICBjb25zdCBkYXRhID0gc25hcHNob3QudmFsKCk7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHVzZXJFbnRyeSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLmZpbmQoKFssIHZhbHVlXTogYW55KSA9PiBcbiAgICAgICAgdmFsdWUudXNlcm5hbWUgPT09IHVzZXJuYW1lICYmIHZhbHVlLnBhc3N3b3JkID09PSBwYXNzd29yZFxuICAgICk7XG5cbiAgICBpZiAoIXVzZXJFbnRyeSkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBbaWQsIHZhbHVlXTogYW55ID0gdXNlckVudHJ5O1xuICAgIGNvbnN0IHVzZXI6IFVzZXIgPSB7IGlkLCAuLi52YWx1ZSB9O1xuXG4gICAgY29uc3QgdXNlclJlZiA9IHJlZihkYiwgYCR7VVNFUlNfQ09MTEVDVElPTn0vJHtpZH1gKTtcbiAgICB1cGRhdGUodXNlclJlZiwgeyBsYXN0TG9naW46IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9KTtcblxuICAgIHJldHVybiB1c2VyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIHZhbGlkYXIgdXN1w6FyaW86XCIsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsVXNlcnMoKTogUHJvbWlzZTxVc2VyW10+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYiA9IGdldEZpcmViYXNlRGF0YWJhc2UoKTtcbiAgICAgICAgY29uc3QgdXNlcnNSZWYgPSByZWYoZGIsIFVTRVJTX0NPTExFQ1RJT04pO1xuICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGF3YWl0IGdldCh1c2Vyc1JlZik7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBzbmFwc2hvdC52YWwoKTtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm4gW107XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGRhdGEpLm1hcCgoW2lkLCB2YWx1ZV06IGFueSkgPT4gKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgLi4udmFsdWVcbiAgICAgICAgfSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvIGFvIGJ1c2NhciB1c3XDoXJpb3M6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJyZWYiLCJvblZhbHVlIiwic2V0IiwicHVzaCIsInVwZGF0ZSIsImdldCIsImdldEZpcmViYXNlRGF0YWJhc2UiLCJJTkZPX0NBVEVHT1JZIiwiQ09MTEVDVElPTl9OQU1FIiwiU1RPUkFHRV9DT0xMRUNUSU9OIiwiU1RPUkFHRV9MT0dTX0NPTExFQ1RJT04iLCJTVE9SQUdFX0RPQ19JRCIsIlVTRVJTX0NPTExFQ1RJT04iLCJpc0ZpcmViYXNlQ29uZmlndXJlZCIsImhhc0FwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZIiwiaGFzUHJvamVjdElkIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCIsImhhc0RhdGFiYXNlVXJsIiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfREFUQUJBU0VfVVJMIiwiZ2V0Q29uZmlnRXJyb3JNZXNzYWdlIiwibWlzc2luZyIsImpvaW4iLCJjcmVhdGVOb3Rlc0xpc3RlbmVyIiwiY2F0ZWdvcnkiLCJjYWxsYmFjayIsImRiIiwibm90ZXNSZWYiLCJ1bnN1YnNjcmliZSIsInNuYXBzaG90IiwiZGF0YSIsInZhbCIsIm5vdGVzIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsImlkIiwidmFsdWUiLCJjcmVhdGVkQXQiLCJEYXRlIiwibm93IiwidXBkYXRlZEF0IiwiZmlsdGVyIiwibm90ZSIsImRlbGV0ZWQiLCJzb3J0IiwiYSIsImIiLCJnZXRUaW1lIiwiZXJyb3IiLCJjb25zb2xlIiwibGlzdGVuVG9Ob3RlcyIsInVzZXJJZCIsImFsbE5vdGVzIiwidXNlck5vdGVzIiwiaW5jbHVkZXMiLCJsaXN0ZW5Ub1JhZGFyTm90ZXMiLCJsaXN0ZW5Ub0luZm9Ob3RlcyIsImFkZE5vdGUiLCJub3RlRGF0YSIsIm5ld05vdGVSZWYiLCJ0b0lTT1N0cmluZyIsIm5ld05vdGUiLCJrZXkiLCJ1cGRhdGVOb3RlIiwidXBkYXRlZEJ5IiwidXBkYXRlZEJ5RGVwYXJ0bWVudCIsIm5vdGVSZWYiLCJ1cGRhdGVkRGF0YSIsImRlbGV0ZU5vdGUiLCJmaWVsZHNUb1VwZGF0ZSIsInRvZ2dsZU5vdGVDb21wbGV0ZWQiLCJjb21wbGV0ZWQiLCJsaXN0ZW5Ub1N0b3JhZ2UiLCJzdG9yYWdlUmVmIiwibGlzdGVuVG9TdG9yYWdlTG9ncyIsImxvZ3NSZWYiLCJsb2dzIiwidGltZXN0YW1wIiwic2F2ZVN0b3JhZ2VTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJ1cGRhdGVkU2VsZWN0aW9uIiwibG9nUmVmIiwibmV3TG9nIiwiY2hhbmdlZEJ5IiwiZGVwYXJ0bWVudCIsImNoYW5nZXMiLCJ0ZWdSb2FkIiwidGVnUm9hZFRvbWJhZG9yIiwidGVnUmFpbHdheU1vZWdhMDEiLCJ0ZWdSYWlsd2F5TW9lZ2EwMiIsInRlYWdSb2FkIiwidGVhZ1JhaWx3YXkiLCJzYXZlT3JVcGRhdGVVc2VyIiwidXNlciIsInVzZXJSZWYiLCJleGlzdGluZ1VzZXIiLCJ1c2VyRGF0YSIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJyb2xlIiwibGFzdExvZ2luIiwidmFsaWRhdGVVc2VyIiwidXNlcnNSZWYiLCJ1c2VyRW50cnkiLCJmaW5kIiwiZ2V0QWxsVXNlcnMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/realtime.ts\n"));

/***/ })

});